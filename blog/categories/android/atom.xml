<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-03-23T15:03:27+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Enable Hide and Internal Classes in Android SDK]]></title>
    <link href="http://zh-wang.github.io/blog/2015/03/23/enable-hide-and-internal-classes-in-android-sdk/"/>
    <updated>2015-03-23T14:36:26+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/03/23/enable-hide-and-internal-classes-in-android-sdk</id>
    <content type="html"><![CDATA[<h2>Hide and Internal Classes</h2>

<p>During android development, you may need to access some method or classes which is not contained in official SDK.<br/>
For example, <code>dalvik.system.VMRuntime</code>, <code>com.android.internal.app.AlertController</code>, etc.<br/>
Although you can done with Java&rsquo;s reflection, it is not developer friendly.<br/>
Here is a more friendly way to do this.</p>

<h2>Preparation</h2>

<p>(I&rsquo;m working on a Mac. But I think procedure is similar if working on other OS.)</p>

<ol>
<li>Android&rsquo;s official SDK. We use android-17(4.2.2) here.</li>
<li>Android emulator.</li>
<li>Can run ruby.</li>
</ol>


<h2>Steps</h2>

<ol>
<li>Create an emulator for 4.2.2 OS. Name it as &ldquo;android422&rdquo;. (by command line or Eclipse)</li>
<li><p>Pull all framework libraries to working machine, which contains all hide and internal classes.</p>

<pre><code> emulator -avd android422
 adb pull /system/framework/* framework
</code></pre></li>
<li><p>Get decompiling tools for odex. Download <code>smali-2.0.3.jar</code> and <code>baksmali-2.0.3.jar</code>. <a href="https://code.google.com/p/smali/">https://code.google.com/p/smali/</a></p></li>
<li>Put them in same directory, run <code>./create_custom_sdk.rb</code></li>
</ol>


<h2>Source</h2>

<pre><code class="ruby">
# -- create_custom_sdk.rb --

#!/usr/bin/env ruby
# encoding: utf-8

# clear 'out' directory
system("rm -rf out")
system("mkdir out")
Dir.chdir("out")

# core.odex(optimized dex) file -&gt; dex file
system("java -jar ../baksmali-2.0.3.jar -a 17 -d ../framework -x ../framework/core.odex -o internal_core_smali")
system("java -jar ../smali-2.0.3.jar -x -o core.dex internal_core_smali")
# framework.odex(optimized dex) file -&gt; dex file
system("java -jar ../baksmali-2.0.3.jar -a 17 -d ../framework -x ../framework/framework.odex -o internal_framework_smali")
system("java -jar ../smali-2.0.3.jar -x -o framework.dex internal_framework_smali")

# .dex -&gt; .class, which contains all symbols including hide and internal
system("dex2jar core.dex")
system("unzip core_dex2jar.jar -d full-symbol-android")
system("dex2jar framework.dex")
system("unzip framework_dex2jar.jar -d full-symbol-android")

# copy offical sdk here
system("cp -r ~/sdk/android-sdk-macosx/platforms/android-17 android422")

# unzip offical android.jar, merge full-symbol-android into it
system("unzip android422/android.jar -d custom-android")
system("cp -r full-symbol-android/* custom-android")
Dir.chdir("custom-android")
system("zip -r9 internal-android.zip *")
Dir.chdir("..")
system("mv custom-android/internal-android.zip android422/android.jar")

# Fix some properties to enable custom sdk shown in Eclipse
filename = "android422/build.prop"
text = File.read(filename)
puts = text.gsub(/ro\.build\.id=.*/, "ro.build.id=Custom422")
  .gsub(/ro\.build\.version\.sdk=17/, "ro.build.version.sdk=422")
  .gsub(/ro\.build\.version\.release=.*/, "ro.build.version.release=4.2.2.c")
File.open(filename, "w") { |file| file &lt;&lt; puts }

filename = "android422/source.properties"
text = File.read(filename)
puts = text.gsub(/AndroidVersion\.ApiLevel=17/, "AndroidVersion.ApiLevel=422")
  .gsub(/Pkg\.Desc=Android SDK Platform 4\.2\.2/, "Pkg.Desc=Android SDK Platform Custom422")
File.open(filename, "w") { |file| file &lt;&lt; puts }

# Copy custom sdk to offical sdk's directory
system("cp -r android422 ~/sdk/android-sdk-macosx/platforms")

puts "Done"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GIF View for Android]]></title>
    <link href="http://zh-wang.github.io/blog/2015/03/10/gif-view-for-android/"/>
    <updated>2015-03-10T23:25:52+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/03/10/gif-view-for-android</id>
    <content type="html"><![CDATA[<h2>Movie view does not work sometimes</h2>

<p>There are several ways to decode and show GIF format image on android.<br/>
I tried using framework&rsquo;s <code>Movie</code> class to decode GIF, but it crashes on device which runs 4.1 or later.<br/>
Don&rsquo;t know why that occurs but I need to show animated GIF on all OS version.<br/>
So I write a custom view to do that, and in a simple way.</p>

<p>Source can be found on <a href="https://github.com/zh-wang/AndroidGifView">Github</a>.</p>

<h2>Something Wired</h2>

<p>GIF&rsquo;s document says that it is encoded in little-endian<a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF Specification</a>.<br/>
But sometimes the HEADER part is in big-endian, like this.</p>

<p><img src="/images/2015_03_10_image01.png" title="GIF image bytes in hex" alt="Image 01" /></p>

<p>The first 6 bytes <code>47 49 46 38 39 61</code> is <code>GIF89a</code>, in big-endian. But sometimes in little-endian.<br/>
So I should read bytes first in <code>BIG_ENDIAN</code>, then turn byte order into <code>LITTLE_ENDIAN</code>.</p>

<pre><code class="java">    /**
     * Reads GIF file header information.
     */
    protected void readHeader() {
        String id = "";
        rawData.order(ByteOrder.BIG_ENDIAN);
        for (int i = 0; i &lt; 6; i++) {
            id += (char) read();
        }
        rawData.order(ByteOrder.LITTLE_ENDIAN);
        if (!id.startsWith("GIF")) {
            status = STATUS_FORMAT_ERROR;
            return;
        }
        readLSD();
        if (gctFlag &amp;&amp; !err()) {
            gct = readColorTable(gctSize);
            bgColor = gct[bgIndex];
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upload Pics by Imgur Api on Android]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/28/upload-image-with-imgur-api-on-android/"/>
    <updated>2015-01-28T16:29:13+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/28/upload-image-with-imgur-api-on-android</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This an example android application which use Imgur&rsquo;s api to upload image, with OAuth2 authorization.</p>

<h2>Steps</h2>

<ol>
<li>You need an account on Imgur. Then create an app from &ldquo;Settings -> Applications&rdquo;. The redirect link should set to <code>YOUR_APP_IDENTIFIER://callback</code> or something else you like, but must match <code>scheme</code> in step 5.</li>
<li>Get your app&rsquo;s client id.</li>
<li>Replace it with <code>CLIENT_ID</code> in the source code.</li>
<li>Create an sample android project with an activity with the source code below.</li>
<li><p>Add following lines to <code>AndroidManifest.xml</code>, under Activity <code>OAuthTestActivity</code>. This allows transition from authorization page to your android app.</p>

<pre><code> &lt;intent-filter&gt;
     &lt;action android:name="android.intent.action.VIEW" /&gt;
     &lt;category android:name="android.intent.category.DEFAULT" /&gt;
     &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
     &lt;data android:scheme="YOUR_APP_IDENTIFIER" android:host="callback" /&gt;
 &lt;/intent-filter&gt;
</code></pre></li>
<li><p>Build and Run.</p></li>
<li>Authorize with your imgur&rsquo;s account with your web browser.
<img src="/images/2015_01_28_image04.png" title="Authorize with your imgur's account" alt="Image A" /></li>
<li>Choose an image to upload.
<img src="/images/2015_01_28_image01.png" title="Choose an image" alt="Image B" /></li>
<li>Upload.
<img src="/images/2015_01_28_image02.png" title="Upload" alt="Image C" /></li>
<li>Check the uploaded image in your web browser.
<img src="/images/2015_01_28_image03.png" title="Open browser" alt="Image D" /></li>
</ol>


<h2>Source Code</h2>

<!-- more -->


<pre><code class="java">
public class OAuthTestActivity extends Activity {

    public static final int REQUEST_CODE_PICK_IMAGE = 1001;

    private static final String AUTHORIZATION_URL = "https://api.imgur.com/oauth2/authorize";
    private static final String CLIENT_ID = "CLIENT_ID";

    private LinearLayout rootView;

    private String accessToken;
    private String refreshToken;

    private String picturePath = "";
    private Button send;

    private String uploadedImageUrl = "";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        rootView = new LinearLayout(this);
        rootView.setOrientation(LinearLayout.VERTICAL);
        TextView tv = new TextView(this);
        LinearLayout.LayoutParams llp = new LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        tv.setLayoutParams(llp);
        rootView.addView(tv);
        setContentView(rootView);

        String action = getIntent().getAction();

        if (action == null || !action.equals(Intent.ACTION_VIEW)) { // We need access token to use Imgur's api

            tv.setText("Start OAuth Authorization");

            Uri uri = Uri.parse(AUTHORIZATION_URL).buildUpon()
                    .appendQueryParameter("client_id", CLIENT_ID)
                    .appendQueryParameter("response_type", "token")
                    .appendQueryParameter("state", "init")
                    .build();

            Intent intent = new Intent();
            intent.setData(uri);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
            finish();

        } else { // Now we have the token, can do the upload

            tv.setText("Got Access Token");

            Uri uri = getIntent().getData();
            Log.d("Got imgur's access token", uri.toString());
            String uriString = uri.toString();
            String paramsString = "http://callback?" + uriString.substring(uriString.indexOf("#") + 1);
            Log.d("tag", paramsString);
            List&lt;NameValuePair&gt; params = URLEncodedUtils.parse(URI.create(paramsString), "utf-8");
            Log.d("tag", Arrays.toString(params.toArray(new NameValuePair[0])));

            for (NameValuePair pair : params) {
                if (pair.getName().equals("access_token")) {
                    accessToken = pair.getValue();
                } else if (pair.getName().equals("refresh_token")) {
                    refreshToken = pair.getValue();
                }
            }

            Log.d("tag", "access_token = " + accessToken);
            Log.d("tag", "refresh_token = " + refreshToken);

            Button chooseImage = new Button(this);
            rootView.addView(chooseImage);
            chooseImage.setText("Choose an image");
            chooseImage.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    Intent intent = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
                    startActivityForResult(intent, REQUEST_CODE_PICK_IMAGE);
                }
            });

            send = new Button(this);
            rootView.addView(send);
            send.setText("send to imgur");
            send.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (picturePath != null &amp;&amp; picturePath.length() &gt; 0 &amp;&amp;
                            accessToken != null &amp;&amp; accessToken.length() &gt; 0) {
                        (new UploadToImgurTask()).execute(picturePath);
                    }
                }
            });
        }

    }

    @Override
    protected void onResume() {
        super.onResume();
        if (send == null) return;
        if (picturePath == null || picturePath.length() == 0) {
            send.setVisibility(View.GONE);
        } else {
            send.setVisibility(View.VISIBLE);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        Log.d("tag", "request code : " + requestCode + ", result code : " + resultCode);
        if (data == null) {
            Log.d("tag" , "data is null");
        }
        if (resultCode == Activity.RESULT_OK &amp;&amp; requestCode == REQUEST_CODE_PICK_IMAGE &amp;&amp; null != data) {
            Uri selectedImage = data.getData();
            String[] filePathColumn = { MediaStore.Images.Media.DATA };

            Cursor cursor = getContentResolver().query(selectedImage,
                    filePathColumn, null, null, null);
            cursor.moveToFirst();

            int columnIndex = cursor.getColumnIndex(filePathColumn[0]);
            picturePath = cursor.getString(columnIndex);
            Log.d("tag", "image path : " + picturePath);
            cursor.close();
        }
        super.onActivityResult(requestCode, resultCode, data);
    }

    // Here is the upload task
    class UploadToImgurTask extends AsyncTask&lt;String, Void, Boolean&gt; {

        @Override
        protected Boolean doInBackground(String... params) {
            final String upload_to = "https://api.imgur.com/3/upload";

            HttpClient httpClient = new DefaultHttpClient();
            HttpContext localContext = new BasicHttpContext();
            HttpPost httpPost = new HttpPost(upload_to);

            try {
                HttpEntity entity = MultipartEntityBuilder.create()
                        .addPart("image", new FileBody(new File(params[0])))
                        .build();

                httpPost.setHeader("Authorization", "Bearer " + accessToken);
                httpPost.setEntity(entity);

                final HttpResponse response = httpClient.execute(httpPost,
                        localContext);

                final String response_string = EntityUtils.toString(response
                        .getEntity());

                final JSONObject json = new JSONObject(response_string);

                Log.d("tag", json.toString());

                JSONObject data = json.optJSONObject("data");
                uploadedImageUrl = data.optString("link");
                Log.d("tag", "uploaded image url : " + uploadedImageUrl);

                return true;
            } catch (Exception e) {
                e.printStackTrace();
            }
            return false;
        }

        @Override
        protected void onPostExecute(Boolean aBoolean) {
            super.onPostExecute(aBoolean);
            if (aBoolean.booleanValue()) { // after sucessful uploading, show the image in web browser
                Button openBrowser = new Button(OAuthTestActivity.this);
                rootView.addView(openBrowser);
                openBrowser.setText("Open Browser");
                openBrowser.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent();
                        intent.setData(Uri.parse(uploadedImageUrl));
                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                    }
                });
            }
        }
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AsyncTask同士は非同期実行]]></title>
    <link href="http://zh-wang.github.io/blog/2014/12/19/android-asynctask-parallelexcution/"/>
    <updated>2014-12-19T12:25:51+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/12/19/android-asynctask-parallelexcution</id>
    <content type="html"><![CDATA[<h2>AsyncTaskはなに？</h2>

<p><a href="http://developer.android.com/reference/android/os/AsyncTask.html">http://developer.android.com/reference/android/os/AsyncTask.html</a></p>

<ul>
<li>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</li>
</ul>


<h2>ほんとに非同期なの？</h2>

<p>AsyncTaskはUIThreadと非同期処理を行うが、AsyncTask同士の間ではデフォルトで<strong>同期</strong>的に行っているみたいね。</p>

<!-- more -->


<pre><code class="java">     private class TestTask extends AsyncTask&lt;Void, Void, Void&gt; /* Params, Progress, Result */ {

        private final int id;
        private final int duration;

        TestTask(int id, int duration) {
            this.id       = id;
            this.duration = duration;
        }

        @Override
        protected Void doInBackground(Void... params) {
            int taskExecutionNumber = executedTasksCount.incrementAndGet();
            log("doInBackground: entered, taskExecutionNumber = " + taskExecutionNumber);
            SystemClock.sleep(duration); // emulates some job
            log("doInBackground: is about to finish, taskExecutionNumber = " + taskExecutionNumber);
            return null;
        }

        private void log(String msg) {
            Log.d("TestTask #" + id, msg);
        }
    }

    // ===========================

    for (int i = 0; i &lt; numberOfTasks; i++) {
        int taskId = i + 1;
        int taskDuration = 1000; // 1000 ms
        TestTask task = new TestTask(taskId, taskDuration);

        // デフォルトでは同期処理。
        // task.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR) が実行される。
        task.execute();
    }
</code></pre>

<p>結果。順番待ちですね。</p>

<p><img src="/images/2014_12_19_image01.png" title="結果1" alt="result_1" /></p>

<pre><code>    for (int i = 0; i &lt; numberOfTasks; i++) {
        int taskId = i + 1;
        int taskDuration = 1000; // 1000 ms
        TestTask task = new TestTask(taskId, taskDuration);

        // こう書くと、非同期実行になる
        // ソース(sdk v.21)を見ると、並列実行ができるExecutorで処理されるぽい
        task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }

    // ========================
    // 以下はAsyncTask.THREAD_POOL_EXECUTORの正体。
    // androidのソースから抜いた
    // ========================

    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE = 1;

    private static final ThreadFactory sThreadFactory = new ThreadFactory() {
        private final AtomicInteger mCount = new AtomicInteger(1);

        public Thread newThread(Runnable r) {
            return new Thread(r, "AsyncTask #" + mCount.getAndIncrement());
        }
    };

    private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =
            new LinkedBlockingQueue&lt;Runnable&gt;(128);

    /**
     * An {@link Executor} that can be used to execute tasks in parallel.
     */
    public static final Executor THREAD_POOL_EXECUTOR =
        new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);
</code></pre>

<p>結果。非同期になった！</p>

<p><img src="/images/2014_12_19_image02.png" title="結果2" alt="結果2" /></p>

<p>因みに、同時に処理できるスレッドの数は、<code>CORE_POOL_SIZE</code>に定義されている。sdk v21の場合、CPUのコア数+1になっている。<br/>
私のテスト端末はクアッドコアなので、同時に５つ走らせる。</p>

<p>それ以上走らせると、やっはり順番待ちになるのね。</p>

<p><img src="/images/2014_12_19_image03.png" title="結果3" alt="結果3" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mozc完全解説02]]></title>
    <link href="http://zh-wang.github.io/blog/2014/05/01/mozc-analysis-02/"/>
    <updated>2014-05-01T15:18:39+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/05/01/mozc-analysis-02</id>
    <content type="html"><![CDATA[<h2>はじめに</h2>

<p><a href="/blog/2014/04/22/mozc-analysis-01/">前回</a>では、android側からタッチ反応を発生してから、jniを通して変換エンジンのnative側が候補を返すまでを説明した。<br/>
今回ではjni部分のコードを少し説明する。</p>

<h2>What is jni?</h2>

<p>言わばjavaとc, cppとの間のインターフェイスですね。cやcppを使って、java側とデータのやり取りができる。<br/>
<a href="http://ja.wikipedia.org/wiki/Java_Native_Interface">Java Native Interface</a></p>

<h2>mozcに使われているjni</h2>

<p>java側ではMozcJNI.javaというラッパーがある。メソッドはこの通り。</p>

<ul>
<li><code>load(String, Buffer, Buffer, String)</code><br/>
  初期化用のメソッド、apkの中に入っている辞書データなどをnative側に渡す</li>
<li><code>evalCommand(byte[])</code><br/>
  native側と通信するメソッド、jniで実装</li>
<li><code>onPostLoad(String, Buffer, Buffer)</code><br/>
  loadメソッドに使われている、jniで実装</li>
<li><code>getVersion()</code><br/>
  native側のバージョン情報をjava側に渡す。loadメソッドに使われている、jniで実装</li>
</ul>


<p>jniの実装ファイルはjni/mozcjni.cc。では、<code>evalCommand(byte[])</code>を詳しく見てみよう。</p>

<!-- more -->


<pre><code class="cpp">// ------&gt; この矢印のあたりは、私の追加したコメントです
jbyteArray JNICALL evalCommand(JNIEnv *env, jclass clazz, jbyteArray in_bytes_array) {
  jboolean is_copy = false;
  jbyte *in_bytes = env-&gt;GetByteArrayElements(in_bytes_array, &amp;is_copy);
  const jsize in_size = env-&gt;GetArrayLength(in_bytes_array);

  // ------&gt; commandにパースする。session/commands.protoにはcommandの定義が書かれいる。
  // ------&gt; protobuf(Protocol Buffers)というライブラリを使っています。
  mozc::commands::Command command;
  command.ParseFromArray(in_bytes, in_size);

  // ------&gt; native側でcommandを処理する。結果はcommandの中に格納する。
  mozc::Singleton&lt;SessionHandlerSingletonAdapter&gt;::get()-&gt;getHandler()
      -&gt;EvalCommand(&amp;command);

  // Use JNI_ABORT because in_bytes is read only.
  // ------&gt; JNI_ABORT: 要素列をJava配列に反映させず、要素列バッファを解放する。
  env-&gt;ReleaseByteArrayElements(in_bytes_array, in_bytes, JNI_ABORT);

  // 変換結果はjbyteArrayとしてjava側に返す
  const int out_size = command.ByteSize();
  jbyteArray out_bytes_array = env-&gt;NewByteArray(out_size);


  // ------&gt; is_copy: 0の場合、生成された配列(out_bytes)を変更すると、java側にも変更される。
  //                  1の場合、変更してもjava側には変更されない。
  jbyte *out_bytes = env-&gt;GetByteArrayElements(out_bytes_array, &amp;is_copy);
  command.SerializeToArray(out_bytes, out_size);

  // Use 0 to copy out_bytes to out_bytes_array.
  // ------&gt; 0の場合、要素列をJava配列に反映させ、要素列バッファを解放する。
  env-&gt;ReleaseByteArrayElements(out_bytes_array, out_bytes, 0);

  return out_bytes_array;
}
</code></pre>

<p><code>in_bytes_array</code>には、タッチされたキーの情報などが入っている。<br/>
<code>out_bytes_array</code>には、変換候補などが入っている。<br/>
<a href="/blog/2014/04/22/mozc-analysis-01/">前回</a>最後のlog部分を参考してくだい。</p>

<h2>終わりに</h2>

<p>jni側の実装に関する説明はここまで。<br/>
次回では<code>evalCommand</code>メソッドをもっと細かく説明する。</p>

<script language="javaScript">
$(document).ready( function () { $("a[href^='http']:not([href*='" + location.hostname + "'])").attr('target', '_blank'); })
</script>



]]></content>
  </entry>
  
</feed>
