<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-05-14T17:04:28+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 14]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14/"/>
    <updated>2015-05-12T12:20:35+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Optional Chaining</h3>

<ul>
<li><p><em>Optional chaining</em> is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.</p>

<ul>
<li>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.</li>
<li>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</li>
<li>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</li>
</ul>
</li>
<li><p>Optional Chaining as an Alternative to Forced Unwrapping</p>

<ul>
<li><p>Sample of Forced Unwarpping
        class Person {
            var residence: Residence?
        }</p>

<pre><code>    class Residence {
        var numberOfRooms = 1
    }

    let john = Persion()

    let roomCount = john.residence!.numberOfRooms
    // this triggers a runtime error, because residence maybe nil
</code></pre></li>
<li><p>Optional chaining provides an alternative way to access the value of numberOfRooms.</p>

<pre><code>    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
    // prints "Unable to retrieve the number of rooms.

    // Even numberOfRooms is Int, optional chaining will always return it as Int?
</code></pre></li>
</ul>
</li>
<li><p>Defining Model Classes for Optional Chaining</p>

<pre><code>      class Residence {
          var rooms = Room[]()
          var numberOfRooms: Int {
          return rooms.count
          }
          subscript(i: Int) -&gt; Room {
              return rooms[i]
          }
          func printNumberOfRooms() {
              println("The number of rooms is \(numberOfRooms)")
          }
          var address: Address?
      }

      class Room {
          let name: String
          init(name: String) { self.name = name }
      }

      class Address {
          var buildingName: String?
          var buildingNumber: String?
          var street: String?
          func buildingIdentifier() -&gt; String? {
              if buildingName {
                  return buildingName
              } else if buildingNumber {
                  return buildingNumber
              } else {
                  return nil
              }
          }
      }
</code></pre></li>
</ul>


<!-- more -->


<ul>
<li><p>Calling Properties Through Optional Chaining</p>

<ul>
<li><p>It is the same as above</p>

<pre><code>    let john = Person()
    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
</code></pre></li>
</ul>
</li>
<li><p>Calling Methods Through Optional Chaining</p>

<pre><code>      func printNumberOfRooms() {
          println("The number of rooms is \(numberOfRooms)")
      }

      “if john.residence?.printNumberOfRooms() {
          println("It was possible to print the number of rooms.")
      } else {
          println("It was not possible to print the number of rooms.")
      }
      // prints "It was not possible to print the number of rooms.
</code></pre></li>
<li><p>Calling Subscripts Through Optional Chaining</p>

<pre><code>      if let firstRoomName = john.residence?[0].name {
          println("The first room name is \(firstRoomName).")
      } else {
          println("Unable to retrieve the first room name.")
      }
      // prints "Unable to retrieve the first room name.
</code></pre></li>
<li><p>Linking Multiple Levels of Chaining</p>

<ul>
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li><p>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</p>

<pre><code>    “if let johnsStreet = john.residence?.address?.street {
        println("John's street name is \(johnsStreet).")
    } else {
        println("Unable to retrieve the address.")
    }
    // prints "Unable to retrieve the address.”
</code></pre></li>
</ul>
</li>
<li><p>Chaining on Methods With Optional Return Values</p>

<pre><code>      if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
          println("John's building identifier is \(buildingIdentifier).")
      }
      // prints "John's building identifier is The Larches.

      “if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
          println("John's uppercase building identifier is \(upper).")
      }
      // prints "John's uppercase building identifier is THE LARCHES.”
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 13 - ARC]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13/"/>
    <updated>2015-01-08T10:13:30+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Automatic Reference Counting</h3>

<ul>
<li><p>Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</p></li>
<li><p>Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</p></li>
<li><p>How ARC Works</p>

<p>  To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The reference is called a “strong“ reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</p></li>
<li><p>ARC in Action</p></li>
</ul>


<pre><code class="swift">        class Person {
            let name: String
            init(name: String) {
                self.name = name
                println("\(name) is being initialized")
            }
            deinit {
                println("\(name) is being deinitialized")
            }
        }

        // The next code snippet defines three variables of type Person?, which are used to set up multiple references to a new Person instance in subsequent code snippets. Because these variables are of an optional type (Person?, not Person), they are automatically initialized with a value of nil, and do not currently reference a Person instance.
        var reference1: Person?
        var reference2: Person?
        var reference3: Person?

        reference2 = reference1
        reference3 = reference1

        reference1 = nil
        reference2 = nil

        reference3 = nil
        // prints "John Appleseed is being deinitialized"
</code></pre>

<!-- more -->


<ul>
<li><p>Strong Reference Cycles Between Class Instances</p>

<p>  It is possible to write code in which an instance of a class never gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Person {
</span><span class='line'>      let name: String
</span><span class='line'>      init(name: String) { self.name = name }
</span><span class='line'>      var apartment: Apartment?
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Apartment {
</span><span class='line'>  let number: Int
</span><span class='line'>  init(number: Int) { self.number = number }
</span><span class='line'>  var tenant: Person?
</span><span class='line'>  deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Person?
</span><span class='line'>  var number73: Apartment?
</span><span class='line'>
</span><span class='line'>  john = Person(name: "John Appleseed")
</span><span class='line'>  number73 = Apartment(number: 73)
</span><span class='line'>
</span><span class='line'>  john!.apartment = number73
</span><span class='line'>  number73!.tenant = john
</span><span class='line'>  // The strong references between the Person instance and the Apartment instance remain and cannot be broken.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles Between Class Instances&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references. Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Weak References&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Weak references must be declared as variables, to indicate that their value can change at runtime. A weak reference cannot be declared as a constant.</span></code></pre></td></tr></table></div></figure>
      class Person {
          let name: String
          init(name: String) { self.name = name }
          var apartment: Apartment?
          deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
      }</p>

<pre><code>  class Apartment {
      let number: Int
      init(number: Int) { self.number = number }
      weak var tenant: Person?
      deinit { println("Apartment #\(number) is being deinitialized") }
  }

  var john: Person?
  var number73: Apartment?

  john = Person(name: "John Appleseed")
  number73 = Apartment(number: 73)

  john!.apartment = number73
  number73!.tenant = john

  john = nil
  // prints "John Appleseed is being deinitialized"
  // The Person instance still has a strong reference to the Apartment instance, but the Apartment instance now has a weak reference to the Person instance. This means that when you break the strong reference held by the john variables, there are no more strong references to the Person instance.
  // Because there are no more strong references to the Person instance, it is deallocated.

  number73 = nil
  // prints "Apartment #73 is being deinitialized"
  // The only remaining strong reference to the Apartment instance is from the number73 variable. If you break that strong reference, there are no more strong references to the Apartment instance.
  // Because there are no more strong references to the Apartment instance, it too is deallocated.
</code></pre>

<p>&#8220;`</p></li>
<li><p>Unowned References</p>

<p>  Like weak references, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is assumed to always have a value. Because of this, an unowned reference is always defined as a non-optional type. You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.</p>

<p>  Because an unowned reference is non-optional, you don’t need to unwrap the unowned reference each time it is used. An unowned reference can always be accessed directly. However, ARC cannot set the reference to nil when the instance it refers to is deallocated, because variables of a non-optional type cannot be set to nil.</p>

<p>  If you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error. Use unowned references only when you are sure that the reference will always refer to an instance.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Customer {
</span><span class='line'>      let name: String
</span><span class='line'>      var card: CreditCard?
</span><span class='line'>      init(name: String) {
</span><span class='line'>          self.name = name
</span><span class='line'>      }
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class CreditCard {
</span><span class='line'>  let number: UInt64
</span><span class='line'>  unowned let customer: Customer
</span><span class='line'>  init(number: UInt64, customer: Customer) {
</span><span class='line'>      self.number = number
</span><span class='line'>      self.customer = customer
</span><span class='line'>  }
</span><span class='line'>  deinit { println("Card #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Customer?
</span><span class='line'>
</span><span class='line'>  john = Customer(name: "John Appleseed")
</span><span class='line'>  john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</span><span class='line'>
</span><span class='line'>  john = nil
</span><span class='line'>  // prints "John Appleseed is being deinitialized"
</span><span class='line'>  // prints "Card #1234567890123456 is being deinitialized"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Unowned References and Implicitly Unwrapped Optional Properties&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Person&lt;/em&gt; and &lt;em&gt;Apartment&lt;/em&gt; example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Customer&lt;/em&gt; and &lt;em&gt;CreditCard&lt;/em&gt; example shows a situation where one property that is allowed to be nil and another property that cannot be nil have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  However, there is a third scenario, in which both properties should always have a value, and neither property should ever be nil once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</span></code></pre></td></tr></table></div></figure>
      class Country {
          let name: String
          let capitalCity: City!
          init(name: String, capitalName: String) {
              self.name = name
              self.capitalCity = City(name: capitalName, country: self)
          }
      }</p>

<pre><code>  class City {
      let name: String
      unowned let country: Country
      init(name: String, country: Country) {
          self.name = name
          self.country = country
      }
  }

  var country = Country(name: "Canada", capitalName: "Ottawa")
  println("\(country.name)'s capital city is called \(country.capitalCity.name)")
  // prints "Canada's capital city is called Ottawa"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Strong Reference Cycles for Closures</p>

<p>  A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // The example below shows how you can create a strong reference cycle when using a closure that references self. This example defines a class called HTMLElement, which provides a simple model for an individual element within an HTML document:
</span><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  // The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // The paragraph variable above is defined as an optional HTMLElement, so that it can be set to nil below to demonstrate the presence of a strong reference cycle.
</span><span class='line'>  var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints "&lt;p&gt;hello, world&lt;/p&gt;"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  Unfortunately, the HTMLElement class, as written above, creates a strong reference cycle between an HTMLElement instance and the closure used for its default asHTML. ( Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance. )
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  paragraph = nil
</span><span class='line'>  // If you set the paragraph variable to nil and break its strong reference to the HTMLElement instance, neither the HTMLElement instance nor its closure are deallocated, because of the strong reference cycle
</span><span class='line'>  // Note that the message in the HTMLElement deinitializer is not printed, which shows that the HTMLElement instance is not deallocated.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles for Closures&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  * Swift requires you to write self.someProperty or self.someMethod (rather than just someProperty or someMethod) whenever you refer to a member of self within a closure. This helps you remember that it’s possible to capture self by accident.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Defining a Capture List&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self or someInstance). These pairings are written within a pair of square braces, separated by commas.</span></code></pre></td></tr></table></div></figure>
      lazy var someClosure: (Int, String) -> String = {
          [unowned self] (index: Int, stringToProcess: String) -> String in
          // closure body goes here
      }</p>

<p>  If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword:</p>

<pre><code>  lazy var someClosure: () -&gt; String = {
      [unowned self] in
      // closure body goes here
  }
</code></pre>

<p>&#8220;`</p></li>
<li>Weak and Unowned References

<ul>
<li>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</li>
<li>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</li>
<li><p>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      [unowned self] in
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  var paragraph: HTMLElement? = HTMLElement(name: &ldquo;p&rdquo;, text: &ldquo;hello, world&rdquo;)
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints &ldquo;&lt;p&gt;hello, world&lt;/p&gt;&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  paragraph = nil
</span><span class='line'>  // prints &ldquo;p is being deinitialized&rdquo;</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 12 - Deinitialization]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/06/learning-swift-part-12/"/>
    <updated>2015-01-06T19:34:40+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/06/learning-swift-part-12</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Deinitialization</h3>

<ul>
<li><p>How Deinitialization Works</p>

<p>  Swift automatically deallocates your instances when they are no longer needed, to free up resources. Swift handles the memory management of instances through automatic reference counting (ARC), as described in Automatic Reference Counting.</p></li>
<li><p>Deinitializers in Action, a sample of Bank operations</p></li>
</ul>


<pre><code class="swift">    struct Bank {
        static var coinsInBank = 10_000
        static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
            numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
            coinsInBank -= numberOfCoinsToVend
            return numberOfCoinsToVend
        }
        static func receiveCoins(coins: Int) {
            coinsInBank += coins
        }
    }

    class Player {
        var coinsInPurse: Int
        init(coins: Int) {
            coinsInPurse = Bank.vendCoins(coins)
        }
        func winCoins(coins: Int) {
            coinsInPurse += Bank.vendCoins(coins)
        }
        deinit {
            Bank.receiveCoins(coinsInPurse)
        }
    }

    var playerOne: Player? = Player(coins: 100)
    println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
    // prints "A new player has joined the game with 100 coins"
    println("There are now \(Bank.coinsInBank) coins left in the bank")
    // prints "There are now 9900 coins left in the bank"

    playerOne!.winCoins(2_000)
    println("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")
    // prints "PlayerOne won 2000 coins &amp; now has 2100 coins"
    println("The bank now only has \(Bank.coinsInBank) coins left")
    // prints "The bank now only has 7900 coins left"

    playerOne = nil
    println("PlayerOne has left the game")
    // prints "PlayerOne has left the game"
    println("The bank now has \(Bank.coinsInBank) coins")
    // prints "The bank now has 10000 coins"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 11 - Inheritance]]></title>
    <link href="http://zh-wang.github.io/blog/2014/11/20/learning-swift-part-11/"/>
    <updated>2014-11-20T19:10:05+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/11/20/learning-swift-part-11</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Inheritance</h3>

<ul>
<li>A base class, Vehicle
<code>
      class Vehicle {
          var currentSpeed = 0.0
          var description: String {
                  return "traveling at \(currentSpeed) miles per hour"
          }
          func makeNoise() {
                  // do nothing - an arbitrary vehicle doesn't necessarily make a noise
          }
      }
</code></li>
<li><p>Subclass, Bicycle and Tandem
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Bicycle: Vehicle {
</span><span class='line'>      var hasBasket = false
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Tandem: Bicycle {
</span><span class='line'>  var currentNumberOfPassengers = 0
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  let tandem = Tandem()
</span><span class='line'>  tandem.hasBasket = true
</span><span class='line'>  tandem.currentNumberOfPassengers = 2
</span><span class='line'>  tandem.currentSpeed = 22.0
</span><span class='line'>  println("Tandem: \(tandem.description)")
</span><span class='line'>  // Tandem: traveling at 22.0 miles per hour
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;!-- more --&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Overriding&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;A subclass can provide its own custom implementation of an instance method, class method, instance property, class property, or subscript that it would otherwise inherit from a superclass. This is known as overriding.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the override keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the override keyword are diagnosed as an error when your code is compiled.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;The override keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Accessing Superclass Methods, Properties, and Subscripts&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;An overridden method named someMethod can call the superclass version of someMethod by calling super.someMethod() within the overriding method implementation.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;An overridden property called someProperty can access the superclass version of someProperty as super.someProperty within the overriding getter or setter implementation.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;An overridden subscript for someIndex can access the superclass version of the same subscript as super[someIndex] from within the overriding subscript implementation.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Overriding Methods</span></code></pre></td></tr></table></div></figure>
      class Train: Vehicle {
          override func makeNoise() {
              println(&ldquo;Choo Choo&rdquo;)
          }
      }</p>

<pre><code>  let train = Train()
  train.makeNoise()
  // prints "Choo Choo"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Overriding Properties</p>

<ul>
<li>You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</li>
</ul>
</li>
<li><p>Overriding Property Getters and Setters</p>

<ul>
<li>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</li>
<li><p>If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, where someProperty is the name of the property you are overriding.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Car: Vehicle {
</span><span class='line'>      var gear = 1
</span><span class='line'>      override var description: String {
</span><span class='line'>          return super.description + &ldquo; in gear (gear)&rdquo;
</span><span class='line'>      }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  let car = Car()
</span><span class='line'>  car.currentSpeed = 25.0
</span><span class='line'>  car.gear = 3
</span><span class='line'>  println(&ldquo;Car: (car.description)&rdquo;)
</span><span class='line'>  // Car: traveling at 25.0 miles per hour in gear 3</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</li>
<li><p>Overriding Property Observers
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class AutomaticCar: Car {
</span><span class='line'>      override var currentSpeed: Double {
</span><span class='line'>          didSet {
</span><span class='line'>              gear = Int(currentSpeed / 10.0) + 1
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let automatic = AutomaticCar()
</span><span class='line'>  automatic.currentSpeed = 35.0
</span><span class='line'>  println("AutomaticCar: \(automatic.description)")
</span><span class='line'>  // AutomaticCar: traveling at 35.0 miles per hour in gear 4
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Preventing Overrides
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;You can prevent a method, property, or subscript from being overridden by marking it as final. Do this by writing the final modifier before the method, property, or subscript’s introducer keyword (such as final var, final func, final class func, and final subscript).&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;You can mark an entire class as final by writing the final modifier before the class keyword in its class definition (final class). Any attempt to subclass a final class is reported as a compile-time error.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Learning Swift Part 10 - Methods]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-10/"/&gt;
</span><span class='line'>&lt;updated&gt;2014-10-24T18:51:55+09:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-10&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h2&gt;===== Full Notes =====&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;Methods&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Instance Methods</span></code></pre></td></tr></table></div></figure>swift
      class Counter {
          var count = 0
          func increment() {
              count++
          }
          func incrementBy(amount: Int) {
              count += amount
          }
          func reset() {
              count = 0
          }
      }</p>

<pre><code>  let counter = Counter()
  // the initial counter value is 0
  counter.increment()
  // the counter's value is now 1
  counter.incrementBy(5)
  // the counter's value is now 6
  counter.reset()
  // the counter's value is now 0
</code></pre>

<p>&#8220;`</p></li>
<li><p>Local and External Parameter Names for Methods<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Counter {
</span><span class='line'>  var count: Int = 0
</span><span class='line'>  func incrementBy(amount: Int, numberOfTimes: Int) {
</span><span class='line'>      count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  let counter = Counter()
</span><span class='line'>  counter.incrementBy(5, numberOfTimes: 3)
</span><span class='line'>  // counter value is now 15
</span><span class='line'>
</span><span class='line'>  // It is behaved as the same as putting a '#' symbol before the name
</span><span class='line'>
</span><span class='line'>  func incrementBy(amount: Int, #numberOfTimes: Int) {
</span><span class='line'>  count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // This will not allow external name
</span><span class='line'>
</span><span class='line'>  func incrementBy(amount: Int, _ : Int) {
</span><span class='line'>  count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;!-- more --&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;The self Property</span></code></pre></td></tr></table></div></figure>
      func increment() {
          self.count++
      }</p>

<pre><code>  struct Point {
      var x = 0.0, y = 0.0
      func isToTheRightOfX(x: Double) -&gt; Bool {
          return self.x &gt; x
      }
  }
  let somePoint = Point(x: 4.0, y: 5.0)
  if somePoint.isToTheRightOfX(1.0) {
      println("This point is to the right of the line where x == 1.0")
  }
  // prints "This point is to the right of the line where x == 1.0"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Modifying Value Types from Within Instance Methods
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct Point {
</span><span class='line'>      var x = 0.0, y = 0.0
</span><span class='line'>      mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>          x += deltaX
</span><span class='line'>          y += deltaY
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  var somePoint = Point(x: 1.0, y: 1.0)
</span><span class='line'>  somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>  println(&ldquo;The point is now at ((somePoint.x), (somePoint.y))&rdquo;)
</span><span class='line'>  // prints &ldquo;The point is now at (3.0, 4.0)&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  // constant instance's properties cannot be modified
</span><span class='line'>
</span><span class='line'>  let fixedPoint = Point(x: 3.0, y: 3.0)
</span><span class='line'>  fixedPoint.moveByX(2.0, y: 3.0)
</span><span class='line'>  // this will report an error
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Assigning to self Within a Mutating Method</span></code></pre></td></tr></table></div></figure>
      struct Point {
          var x = 0.0, y = 0.0
          mutating func moveByX(deltaX: Double, y deltaY: Double) {
              self = Point(x: x + deltaX, y: y + deltaY)
          }
      }</p>

<pre><code>  enum TriStateSwitch {
      case Off, Low, High
      mutating func next() {
          switch self {
          case Off:
              self = Low
          case Low:
              self = High
          case High:
              self = Off
          }
      }
  }
  var ovenLight = TriStateSwitch.Low
  ovenLight.next()
  // ovenLight is now equal to .High
  ovenLight.next()
  // ovenLight is now equal to .Off
</code></pre>

<p>&#8220;`</p></li>
<li><p>Type Methods
&#8220;`
      class SomeClass {
          class func someTypeMethod() {
              // type method implementation goes here
          }
      }
      SomeClass.someTypeMethod()</p>

<pre><code>  // Within the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type. For structures and enumerations, this means that you can use self to disambiguate between static properties and static method parameters, just as you do for instance properties and instance method parameters.

  struct LevelTracker {
      static var highestUnlockedLevel = 1
      static func unlockLevel(level: Int) {
          if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
      }
      static func levelIsUnlocked(level: Int) -&gt; Bool {
          return level &lt;= highestUnlockedLevel
      }
      var currentLevel = 1
      mutating func advanceToLevel(level: Int) -&gt; Bool {
          if LevelTracker.levelIsUnlocked(level) {
              currentLevel = level
              return true
          } else {
              return false
          }
      }
  }

  class Player {
      var tracker = LevelTracker()
      let playerName: String
      func completedLevel(level: Int) {
          LevelTracker.unlockLevel(level + 1)
          tracker.advanceToLevel(level + 1)
      }
      init(name: String) {
          playerName = name
      }
  }

  var player = Player(name: "Argyrios")
  player.completedLevel(1)
  println("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
  // prints "highest unlocked level is now 2"

  player = Player(name: "Beto")
  if player.tracker.advanceToLevel(6) {
      println("player is now on level 6")
  } else {
      println("level 6 has not yet been unlocked")
  }
  // prints "level 6 has not yet been unlocked"
</code></pre>

<p>&#8220;`</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
