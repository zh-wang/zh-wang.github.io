<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2014-09-24T18:10:05+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 5]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/19/learning-swift-part-5/"/>
    <updated>2014-09-19T15:14:08+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/19/learning-swift-part-5</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<p>Tuple in switch statement is interesting.</p>

<h2>===== Full Notes =====</h2>

<h3>Control Flow</h3>

<ul>
<li>For-In

<ul>
<li><p>Sample</p>

<pre><code>  for index in 1...5 {
      println("\(index) times 5 is \(index * 5)")
  }
  // 1 times 5 is 5
  // 2 times 5 is 10
  // 3 times 5 is 15
  // 4 times 5 is 20
  // 5 times 5 is 25
</code></pre></li>
<li><p>if no need of value from the range</p>

<pre><code>  let base = 3
  let power = 10
  var answer = 1
  for _ in 1...power {
      answer *= base
  }
  println("\(base) to the power of \(power) is \(answer)")
  // prints "3 to the power of 10 is 59049"
</code></pre></li>
<li><p>Use in array</p>

<pre><code>  let names = ["Anna", "Alex", "Brian", "Jack"]
  for name in names {
      println("Hello, \(name)!")
  }
  // Hello, Anna!
  // Hello, Alex!
  // Hello, Brian!
  // Hello, Jack!
</code></pre></li>
<li><p>Use in dictionary</p>

<pre><code>  let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
  for (animalName, legCount) in numberOfLegs {
      println("\(animalName)s have \(legCount) legs")
  }
  // spiders have 8 legs
  // cats have 4 legs
  // ants have 6 legs
</code></pre></li>
<li><p>Use in string</p>

<pre><code>  for character in "Hello" {
      println(character)
  }
  // H
  // e
  // l
  // l
  // o
</code></pre></li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>For</p>

<ul>
<li><p>Sample</p>

<pre><code>  for var index = 0; index &lt; 3; ++index {
      println("index is \(index)")
  }
  // index is 0
  // index is 1
  // index is 2
</code></pre></li>
<li><p>Index is only accessible in the loop</p>

<pre><code>  var index: Int
  for index = 0; index &lt; 3; ++index {
      println("index is \(index)")
  }
  // index is 0
  // index is 1
  // index is 2
  println("The loop statements were executed \(index) times")
  // prints "The loop statements were executed 3 times"
</code></pre></li>
</ul>
</li>
<li><p>While Loops</p>

<ul>
<li><p>Snakes and Ladders</p>

<pre><code>  let finalSquare = 25
  var board = [Int](count: finalSquare + 1, repeatedValue: 0)

  board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
  board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08

  var square = 0
  var diceRoll = 0
  while square &lt; finalSquare {
      // roll the dice
      if ++diceRoll == 7 { diceRoll = 1 }
      // move by the rolled amount
      square += diceRoll
      if square &lt; board.count {
          // if we're still on the board, move up or down for a snake or a ladder
          square += board[square]
      }
  }
  println("Game over!")
</code></pre></li>
</ul>
</li>
<li><p>Do-While</p>

<ul>
<li><p>Snakes and Ladders</p>

<pre><code>  let finalSquare = 25
  var board = [Int](count: finalSquare + 1, repeatedValue: 0)
  board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
  board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
  var square = 0
  var diceRoll = 0

  do {
      // move up or down for a snake or ladder
      square += board[square]
      // roll the dice
      if ++diceRoll == 7 { diceRoll = 1 }
      // move by the rolled amount
      square += diceRoll
  } while square &lt; finalSquare
  println("Game over!")
</code></pre></li>
</ul>
</li>
<li><p>If</p>

<ul>
<li><p>Sample
      var temperatureInFahrenheit = 30
      if temperatureInFahrenheit &lt;= 32 {
          println(&ldquo;It&rsquo;s very cold. Consider wearing a scarf.&rdquo;)
      }
      // prints &ldquo;It&rsquo;s very cold. Consider wearing a scarf.&rdquo;</p>

<pre><code>  temperatureInFahrenheit = 40
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else {
      println("It's not that cold. Wear a t-shirt.")
  }
  // prints "It's not that cold. Wear a t-shirt."

  temperatureInFahrenheit = 90
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else if temperatureInFahrenheit &gt;= 86 {
      println("It's really warm. Don't forget to wear sunscreen.")
  } else {
      println("It's not that cold. Wear a t-shirt.")
  }
  // prints "It's really warm. Don't forget to wear sunscreen."

  temperatureInFahrenheit = 72
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else if temperatureInFahrenheit &gt;= 86 {
      println("It's really warm. Don't forget to wear sunscreen.")
  }
</code></pre></li>
</ul>
</li>
<li><p>Switch</p>

<ul>
<li><p>Sample</p>

<pre><code>  switch some value to consider {
  case value 1:
      respond to value 1
  case value 2,
  value 3:
      respond to value 2 or 3
  default:
      otherwise, do something else
  }
</code></pre></li>
<li><p>Use with char</p>

<pre><code>  let someCharacter: Character = "e"
  switch someCharacter {
  case "a", "e", "i", "o", "u":
      println("\(someCharacter) is a vowel")
  case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
  "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
      println("\(someCharacter) is a consonant")
  default:
      println("\(someCharacter) is not a vowel or a consonant")
  }
  // prints "e is a vowel"
</code></pre></li>
<li><p>No Implicit Fallthrough</p>

<p>  In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than in C, and avoids executing more than one switch case by mistake.</p></li>
<li><p>Bad case</p>

<pre><code>  let anotherCharacter: Character = "a"
  switch anotherCharacter {
  case "a":                       // Each case must contain at least one executable statement.
  case "A":
      println("The letter A")
  default:
      println("Not the letter A")
  }
  // this will report a compile-time error
</code></pre></li>
<li><p>Range Matching</p>

<pre><code>  let count = 3_000_000_000_000
  let countedThings = "stars in the Milky Way"
  var naturalCount: String
  switch count {
  case 0:
      naturalCount = "no"
  case 1...3:
      naturalCount = "a few"
  case 4...9:
      naturalCount = "several"
  case 10...99:
      naturalCount = "tens of"
  case 100...999:
      naturalCount = "hundreds of"
  case 1000...999_999:
      naturalCount = "thousands of"
  default:
      naturalCount = "millions and millions of"
  }
</code></pre></li>
<li><p>Tuple</p>

<pre><code>  let somePoint = (1, 1)
  switch somePoint {
  case (0, 0):
      println("(0, 0) is at the origin")
  case (_, 0):
      println("(\(somePoint.0), 0) is on the x-axis")
  case (0, _):
      println("(0, \(somePoint.1)) is on the y-axis")
  case (-2...2, -2...2):
      println("(\(somePoint.0), \(somePoint.1)) is inside the box")
  default:
      println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
  }
  // prints "(1, 1) is inside the box"
</code></pre></li>
<li><p>Value Bindings</p>

<pre><code>  let anotherPoint = (2, 0)
  switch anotherPoint {
  case (let x, 0):
      println("on the x-axis with an x value of \(x)")
  case (0, let y):
      println("on the y-axis with a y value of \(y)")
  case let (x, y):
      println("somewhere else at (\(x), \(y))")
  }
  // prints "on the x-axis with an x value of 2"
</code></pre></li>
<li><p>Where</p>

<pre><code>  let yetAnotherPoint = (1, -1)
  switch yetAnotherPoint {
  case let (x, y) where x == y:
      println("(\(x), \(y)) is on the line x == y")
  case let (x, y) where x == -y:
      println("(\(x), \(y)) is on the line x == -y")
  case let (x, y):
      println("(\(x), \(y)) is just some arbitrary point")
  }
  // prints "(1, -1) is on the line x == -y"
</code></pre></li>
</ul>
</li>
<li><p>Control Transfer Statements</p>

<ul>
<li><p>Continue<br/>
The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.</p>

<pre><code>    let puzzleInput = "great minds think alike"
    var puzzleOutput = ""
    for character in puzzleInput {
        switch character {
        case "a", "e", "i", "o", "u", " ":
            continue
        default:
            puzzleOutput.append(character)
        }
    }
    println(puzzleOutput)
    // prints "grtmndsthnklk"
</code></pre>

<ul>
<li><p>Break</p>

<pre><code>  let numberSymbol: Character = "三"  // Simplified Chinese for the number 3
  var possibleIntegerValue: Int?
  switch numberSymbol {
  case "1", "١", "一", "๑":
      possibleIntegerValue = 1
  case "2", "٢", "二", "๒":
      possibleIntegerValue = 2
  case "3", "٣", "三", "๓":
      possibleIntegerValue = 3
  case "4", "٤", "四", "๔":
      possibleIntegerValue = 4
  default:
      break
  }
  if let integerValue = possibleIntegerValue {
      println("The integer value of \(numberSymbol) is \(integerValue).")
  } else {
      println("An integer value could not be found for \(numberSymbol).")
  }
  // prints "The integer value of 三 is 3."
</code></pre></li>
<li><p>Explicit Fallthrough<br/>
The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.</p>

<pre><code>  let integerToDescribe = 5
  var description = "The number \(integerToDescribe) is"
  switch integerToDescribe {
  case 2, 3, 5, 7, 11, 13, 17, 19:
      description += " a prime number, and also"
      fallthrough
  default:
      description += " an integer."
  }
  println(description)
  // prints "The number 5 is a prime number, and also an integer."
</code></pre></li>
<li><p>Labeled Statements</p>

<pre><code>  gameLoop: while square != finalSquare {
      if ++diceRoll == 7 { diceRoll = 1 }
      switch square + diceRoll {
      case finalSquare:
          // diceRoll will move us to the final square, so the game is over
          break gameLoop
      case let newSquare where newSquare &gt; finalSquare:
          // diceRoll will move us beyond the final square, so roll again
          continue gameLoop
      default:
          // this is a valid move, so find out its effect
          square += diceRoll
          square += board[square]
      }
  }
  println("Game over!")
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 4]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/08/learning-swift-part-4/"/>
    <updated>2014-09-08T18:03:31+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/08/learning-swift-part-4</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Strings and Characters</h3>

<ul>
<li><p>String Literals</p>

<pre><code>  let someString = "..."
</code></pre></li>
<li><p>Initializing an Empty String</p>

<pre><code>  var emptyString = ""               // empty string literal
  var anotherEmptyString = String()  // initializer syntax
  // these two strings are both empty, and are equivalent to each other

  if emptyString.isEmpty {
      println("Nothing to see here")
  }
</code></pre></li>
<li><p>String Mutability</p>

<pre><code>  var variableString = "Horse"
  variableString += " and carriage"
  // variableString is now "Horse and carriage"

  let constantString = "Highlander"
  constantString += " and another Highlander"
  // this reports a compile-time error - a constant string cannot be modified
</code></pre></li>
<li><p>Strings Are Value Types</p>

<ul>
<li>Swift’s String type is a value type. If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version.</li>
<li>NSString in obj-c is NOT value type.</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>Working with Characters</p>

<pre><code>  for character in "Dog!🐶" {
      println(character)
  }

  // a single character
  let yenSign: Character = "¥"
</code></pre></li>
<li><p>Concatenating Strings and Characters</p>

<pre><code>  let string1 = "hello"
  let string2 = " there"
  var welcome = string1 + string2
  // welcome now equals "hello there"

  var instruction = "look over"
  instruction += string2
  // instruction now equals "look over there"

  let exclamationMark: Character = "!"
  welcome.append(exclamationMark)
  // welcome now equals "hello there!"
</code></pre></li>
<li><p>String Interpolation</p>

<pre><code>  let multiplier = 3
  let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
  // message is "3 times 2.5 is 7.5"
</code></pre></li>
<li><p>Unicode Scalars</p></li>
<li><p>Special Unicode Characters in String Literals</p>

<pre><code>  let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
  // "Imagination is more important than knowledge" - Einstein
  let dollarSign = "\u{24}"        // $,  Unicode scalar U+0024
  let blackHeart = "\u{2665}"      // ♥,  Unicode scalar U+2665
  let sparklingHeart = "\u{1F496}" // 💖, Unicode scalar U+1F496
</code></pre></li>
<li><p>Extended Grapheme Clusters</p>

<pre><code>  let eAcute: Character = "\u{E9}"                         // é
  let combinedEAcute: Character = "\u{65}\u{301}"          // e followed by ́
  // eAcute is é, combinedEAcute is é

  let precomposed: Character = "\u{D55C}"                  // 한
  let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // ᄒ, ᅡ, ᆫ
  // precomposed is 한, decomposed is 한

  let enclosedEAcute: Character = "\u{E9}\u{20DD}"
  // enclosedEAcute is é⃝
</code></pre></li>
<li><p>Counting Characters</p>

<pre><code>  let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
  println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
  // prints "unusualMenagerie has 40 characters"

  var word = "cafe"
  println("the number of characters in \(word) is \(countElements(word))
  // prints "the number of characters in cafe is 4"

  word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301

  println("the number of characters in \(word) is \(countElements(word))
  // prints "the number of characters in café is 4"
</code></pre></li>
<li><p>Comparing Strings</p>

<ul>
<li><p>String and Character Equality</p>

<pre><code>  let quotation = "We're a lot alike, you and I."
  let sameQuotation = "We're a lot alike, you and I."
  if quotation == sameQuotation {
      println("These two strings are considered equal")
  }
  // prints "These two strings are considered equal"
</code></pre></li>
<li><p>Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent.</p>

<pre><code>  // "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE
  let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"

  // "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
  let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"

  if eAcuteQuestion == combinedEAcuteQuestion {
      println("These two strings are considered equal")
  }
  // prints "These two strings are considered equal"
</code></pre></li>
<li><p>Conversely, LATIN CAPITAL LETTER A (U+0041, or &ldquo;A&rdquo;), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or &ldquo;А&rdquo;).</p>

<pre><code>  let latinCapitalLetterA: Character = "\u{41}"

  let cyrillicCapitalLetterA: Character = "\u{0410}"

  if latinCapitalLetterA != cyrillicCapitalLetterA {
      println("These two characters are not equivalent")
  }
  // prints "These two characters are not equivalent"
</code></pre></li>
<li><p>Prefix and Suffix Equality</p>

<pre><code>  let romeoAndJuliet = [
      "Act 1 Scene 1: Verona, A public place",
      "Act 1 Scene 2: Capulet's mansion",
      "Act 1 Scene 3: A room in Capulet's mansion",
      "Act 1 Scene 4: A street outside Capulet's mansion",
      "Act 1 Scene 5: The Great Hall in Capulet's mansion",
      "Act 2 Scene 1: Outside Capulet's mansion",
      "Act 2 Scene 2: Capulet's orchard",
      "Act 2 Scene 3: Outside Friar Lawrence's cell",
      "Act 2 Scene 4: A street in Verona",
      "Act 2 Scene 5: Capulet's mansion",
      "Act 2 Scene 6: Friar Lawrence's cell"
  ]

  var act1SceneCount = 0
  for scene in romeoAndJuliet {
      if scene.hasPrefix("Act 1 ") {
          ++act1SceneCount
      }
  }
  println("There are \(act1SceneCount) scenes in Act 1")
  // prints "There are 5 scenes in Act 1"

  var mansionCount = 0
  var cellCount = 0
  for scene in romeoAndJuliet {
      if scene.hasSuffix("Capulet's mansion") {
          ++mansionCount
      } else if scene.hasSuffix("Friar Lawrence's cell") {
          ++cellCount
      }
  }
  println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
  // prints "6 mansion scenes; 2 cell scenes"
</code></pre></li>
<li><p>A collection of UTF-8 code units (accessed with the string’s utf8 property)</p></li>
<li>A collection of UTF-16 code units (accessed with the string’s utf16 property)</li>
<li>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s unicodeScalars property)</li>
</ul>
</li>
<li><p>UTF-8 Representation</p>

<pre><code>  let dogString = "Dog‼🐶"

  for codeUnit in dogString.utf8 {
      print("\(codeUnit) ")
  }
  print("\n")
  // 68 111 103 226 128 188 240 159 144 182
</code></pre></li>
<li><p>UTF-16 Representation</p>

<pre><code>  for codeUnit in dogString.utf16 {
      print("\(codeUnit) ")
  }
  print("\n")
  // 68 111 103 8252 55357 56374
</code></pre></li>
<li><p>Unicode Scalar Representation</p>

<pre><code>  for scalar in dogString.unicodeScalars {
      print("\(scalar.value) ")
  }
  print("\n")
  // 68 111 103 8252 128054

  for scalar in dogString.unicodeScalars {
      println("\(scalar) ")
  }
  // D
  // o
  // g
  // ‼
  // 🐶
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning-swift-part-3]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-3/"/>
    <updated>2014-09-05T17:59:28+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-3</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Basic Operators</h3>

<ul>
<li><p>Terminology</p>

<pre><code>  - Unary
  - Binary
  - Ternary (There is only one in a ? b :c)
</code></pre></li>
<li><p>Assignment Operator</p>

<pre><code>  // Not a vaild assignment
  if x = y {

  }
</code></pre></li>
<li><p>Arithmetic Operators</p>

<ul>
<li>Not allow overflow.</li>
<li>You can opt in to value overflow behavior by using Swift&rsquo;s overflow operators (such as a &amp;+ b).</li>
<li><p>The addition operator is also supported for <strong>String</strong> concatenation.</p>

<p>  let dog: Character = &ldquo;🐶&rdquo;
  let cow: Character = &ldquo;🐮&rdquo;
  let dogCow = dog + cow
  // dogCow is equal to &ldquo;🐶🐮&rdquo;</p></li>
</ul>
</li>
<li><p>Remainder Operator</p>

<ul>
<li><code>9 % 4 // equals 1</code></li>
<li><code>-9 % 4 // equals -1</code></li>
<li><code>-9 % 4 // equals -9 % -4</code></li>
</ul>
</li>
</ul>


<!-- more -->


<p></p>

<ul>
<li><p>Floating-Point Remainder Calculations</p>

<ul>
<li><code>8 % 2.5 // equals 0.5</code></li>
</ul>
</li>
<li><p>Increment and Decrement Operators</p>

<ul>
<li><code>++</code> and <code>--</code> works the same as C</li>
</ul>
</li>
<li><p>Unary Minus Operator and Unary Plus Operator</p>

<ul>
<li><code>+</code> do <strong>NOT</strong> change the value</li>
</ul>
</li>
<li><p>Compound Assignment Operators</p>

<pre><code>  var a = 1
  a += 2
</code></pre></li>
<li><p>Comparison Operators</p>

<pre><code>  Equal to (a == b)
  Not equal to (a != b)
  Greater than (a &gt; b)
  Less than (a &lt; b)
  Greater than or equal to (a &gt;= b)
  Less than or equal to (a &lt;= b)
</code></pre></li>
<li><p>Nil Coalescing Operator</p>

<ul>
<li><p>The nil coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil.</p>

<p>  let defaultColorName = &ldquo;red&rdquo;
  var userDefinedColorName: String?   // defaults to nil</p>

<p>  var colorNameToUse = userDefinedColorName ?? defaultColorName
  // userDefinedColorName is nil, so colorNameToUse is set to the default of &ldquo;red&rdquo;</p></li>
</ul>
</li>
<li><p>Range Operators</p>

<pre><code>  for index in 1...5 {
      println("\(index) times 5 is \(index * 5)")
  }
  // 1 times 5 is 5
  // 2 times 5 is 10
  // 3 times 5 is 15
  // 4 times 5 is 20
  // 5 times 5 is 25
</code></pre></li>
<li><p>Half-Open Range Operator</p>

<pre><code>  let names = ["Anna", "Alex", "Brian", "Jack"]
  let count = names.count
  for i in 0..&lt;count {
      println("Person \(i + 1) is called \(names[i])")
  }
  // Person 1 is called Anna
  // Person 2 is called Alex
  // Person 3 is called Brian
  // Person 4 is called Jack&gt;
</code></pre></li>
<li><p>Logical Operators</p>

<ul>
<li>Logical NOT (!a)</li>
<li>Logical AND (a &amp;&amp; b)</li>
<li>Logical OR (a || b)</li>
<li>Logical NOT (!a)</li>
</ul>
</li>
<li><p>Combining Logical Operators</p>

<pre><code>  if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
      println("Welcome!")
  } else {
      println("ACCESS DENIED")
  }
  // prints "Welcome!"
</code></pre></li>
<li><p>Explicit Parentheses</p>

<pre><code>  if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
      println("Welcome!")
  } else {
      println("ACCESS DENIED")
  }
  // prints "Welcome!"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 2]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-2/"/>
    <updated>2014-09-05T15:06:10+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-2</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Basics</h3>

<ul>
<li><p>Declaring Constant and Variables</p>

<pre><code>  let maximumNumberOfLoginAttempts = 10
  var currentLoginAttempt = 0

  var x = 0.0, y = 0.0, z = 0.0
</code></pre></li>
<li><p>Type Annotations</p>

<pre><code>  var welcomeMessgae: String
  welcomeMessgae = "Hello"

  var red, green, blue: Double // Multiple variables defined
</code></pre></li>
<li><p>Naming Constants and Variables</p>

<pre><code>  let π = 3.14159
  let 你好 = "你好世界"
  let 🐶🐮 = "dogcow"
</code></pre></li>
</ul>


<!-- more -->


<ul>
<li><p>Integers</p>

<ul>
<li><p>Integer Bounds</p>

<pre><code>  let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
  let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
</code></pre></li>
<li><p>Int</p>

<ul>
<li>On a 32-bit platform, Int is the same size as Int32.</li>
<li>On a 64-bit platform, Int is the same size as Int64.</li>
</ul>
</li>
<li><p>UInt</p>

<ul>
<li>On a 32-bit platform, UInt is the same size as UInt32.</li>
<li>On a 64-bit platform, UInt is the same size as UInt64.</li>
</ul>
</li>
<li><p>Floating-Point Numbers</p>

<ul>
<li>Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits. T</li>
</ul>
</li>
<li><p>Type Safety and Type Inference</p></li>
<li><p>Numeric Literals</p>

<pre><code>  let decimalInteger = 17
  let binaryInteger = 0b10001       // 17 in binary notation
  let octalInteger = 0o21           // 17 in octal notation
  let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

  1.25e2          // 125.0
  1.25e-2         // 0.0125
  0xFp2           // 60.0 = 15 x 2 x 2
  0xFp-2          // 3.75 = 15 x 0.5 x 0.5

  // Can have additional formatting literal (like Ruby)

  let paddedDouble = 000123.456
  let oneMillion = 1_000_000
  let justOverOneMillion = 1_000_000.000_000_1
</code></pre></li>
<li><p>Integer Conversion</p>

<pre><code>  let cannotBeNegative: UInt8 = -1
  // UInt8 cannot store negative numbers, and so this will report an error
  let tooBig: Int8 = Int8.max + 1
  // Int8 cannot store a number larger than its maximum value,
  // and so this will also report an error

  // conversion must be explicit

  let twoThousand: UInt16 = 2_000
  let one: UInt8 = 1
  let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre></li>
<li><p>Integer and Floating-Point Conversion</p>

<pre><code>  let three = 3
  let pointOneFourOneFiveNine = 0.14159
  let pi = Double(three) + pointOneFourOneFiveNine
  // pi equals 3.14159, and is inferred to be of type Double

  let integerPi = Int(pi)
  // integerPi equals 3, and is inferred to be of type Int
</code></pre></li>
<li><p>Type Aliases</p>

<pre><code>  typealias AudioSample = UInt16
  var maxAmplitudeFound = AudioSample.min
  // maxAmplitudeFound is now 0
</code></pre></li>
</ul>
</li>
<li><p>Boolean</p>

<pre><code>  let orangesAreOrange = true
  let turnipsAreDelicious = false

  if turnipsAreDelicious {
      println("Mmm, tasty turnips!")
  } else {
      println("Eww, turnips are horrible.")
  }
  // prints "Eww, turnips are horrible."
</code></pre></li>
<li><p>Tuples</p>

<pre><code>  let http404Error = (404, "Not Found")
  // http404Error is of type (Int, String), and equals (404, "Not Found")
</code></pre>

<ul>
<li><p>Decompose a tuple</p>

<pre><code>  let (statusCode, statusMessage) = http404Error
  println("The status code is \(statusCode)")
  // prints "The status code is 404"
  println("The status message is \(statusMessage)")
  // prints "The status message is Not Found"
</code></pre></li>
<li><p>Ignore some value when decomposing</p>

<pre><code>  let (justTheStatusCode, _) = http404Error
  println("The status code is \(justTheStatusCode)")
  // prints "The status code is 404"
</code></pre></li>
<li><p>Access by index</p>

<pre><code>  println("The status code is \(http404Error.0)")
  // prints "The status code is 404"
  println("The status message is \(http404Error.1)")
  // prints "The status message is Not Found"
</code></pre></li>
</ul>
</li>
<li><p>Optionals</p>

<pre><code>  let possibleNumber = "123"
  let convertedNumber = possibleNumber.toInt()
  // convertedNumber is inferred to be of type "Int?", or "optional Int"
</code></pre></li>
<li><p>nil</p>

<pre><code>  var serverResponseCode: Int? = 404
  // serverResponseCode contains an actual Int value of 404
  serverResponseCode = nil
  // serverResponseCode now contains no value

  var surveyAnswer: String?
  // surveyAnswer is automatically set to nil
</code></pre></li>
<li><p>If Statements and Forced Unwrapping</p>

<pre><code>  if convertedNumber != nil {
      println("convertedNumber has an integer value of \(convertedNumber!).")
  }
  // prints "convertedNumber has an integer value of 123."
</code></pre></li>
<li><p>Optional Binding</p>

<pre><code>  if let constantName = someOptional {
      statements
  }

  if let actualNumber = possibleNumber.toInt() {
      println("\(possibleNumber) has an integer value of \(actualNumber)")
  } else {
      println("\(possibleNumber) could not be converted to an integer")
  }
  // prints "123 has an integer value of 123"
</code></pre></li>
<li><p>Implicitly Unwrapping Optionals (Accessing an implicitly unwrapped optional when it does not contain a value will trigger a RTE)</p>

<pre><code>  let possibleString: String? = "An optional string."
  let forcedString: String = possibleString! // requires an exclamation mark

  let assumedString: String! = "An implicitly unwrapped optional string."
  let implicitString: String = assumedString // no need for an exclamation mark

  if assumedString != nil {
      println(assumedString)
  }
  // prints "An implicitly unwrapped optional string."

  if let definiteString = assumedString {
      println(definiteString)
  }
  // prints "An implicitly unwrapped optional string."
</code></pre></li>
<li><p>Assertions</p></li>
<li><p>Debugging with Assertions</p>

<pre><code>  let age = -3
  assert(age &gt;= 0, "A person's age cannot be less than zero")
  // this causes the assertion to trigger, because age is not &gt;= 0
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 1]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/02/learning-swift-part-1/"/>
    <updated>2014-09-02T18:28:36+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/02/learning-swift-part-1</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<p>Modified some code in the following parts. Some better example or fixing in new Xcode.</p>

<ul>
<li><p>Function as parameter (like Comparator)
<code>swift
  // Bubble sort with a custom comparator
  func sort(inout list: [Int], sorter: ((Int, Int) -&gt; Bool)) {
      var i : Int = 0
      while i &lt; list.count {
          var j : Int = i + 1
          if j &lt; list.count &amp;&amp; !sorter(list[i], list[j]) {
              var temp = list[i]
              list[i] = list[j]
              list[j] = temp
          }
          i++
      }
  }
  var list = [3, 2, 1]
  func sorter(a : Int, b : Int) -&gt; Bool {
      return a &lt; b
  }
  sort(&amp;list, sorter)
</code></p></li>
<li><p>Closure
<code>swift
  numbers.map({
      (number: Int) -&gt; Int in
      let result = 3 * number
      return result
  })
  // can be simplied to
  numbers.map({ number in 3 * number })
  // sort a array
  var list = [3, 2, 1]
  sort(&amp;list) // NOT sort(list), this function only accept a reference
  var listSorted = sorted(list) // This is OK
</code></p></li>
</ul>


<!-- more -->


<h2>===== Full Notes =====</h2>

<h3>A Swift Tour</h3>

<ul>
<li>variable.
<code>
      var myVariable = 42   // variable
      myVariable = 50       // variable
      let myConstant = 42   // Constant
</code></li>
<li><strong>implicit</strong> vs <strong>explicit</strong>.
<code>
      let implicitInteger = 70
      let implicitDouble = 70.0
      let explicitDouble: Double = 70  // Type is written right to variable
</code></li>
<li>Values never implicitly converted.
<code>
      let label = "The width is"
      let width = 94
      let withlabel = label + String(width)
</code></li>
<li>Include values in strings.
<code>
      let apples = 3
      let oranges = 5
      let appleSummary = "I have \(apples) apples."
      let fruitSummary = "I have \(apples + oranges) pieces of fruit."
</code></li>
<li><p><strong>Arrays</strong> and <strong>Dictionaries</strong>.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var shopppingList = [&ldquo;catfish&rdquo;, &ldquo;water&rdquo;, &ldquo;tulips&rdquo;, &ldquo;blue paint&rdquo;] // [] for empty array
</span><span class='line'>  shoppingList[1] = &ldquo;bottle of water&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  var occupations = [
</span><span class='line'>  "Malcolm": "Captain",
</span><span class='line'>  "Kaylee": "Mechanic",
</span><span class='line'>  ] // [:] for empty dictionary
</span><span class='line'>  occupations["Jayne"] = "Public Relations"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span></code></pre></td></tr></table></div></figure>

<h2>Control Flows</h2></li>
<li><p><strong>for-in</strong>
<code>
      let individualScores = [75, 43, 103, 87, 12]
      var teamScore = 0
      for score in individualScores {
          if score &gt; 50 {
              teamScore += 3
          } else {
              teamScore += 1
          }
      }
      teamScore
</code></p></li>
<li><p>optional-value with <strong>if</strong>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  var optionalString: String? = &ldquo;Hello&rdquo;
</span><span class='line'>  optionalString == nil&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  var optionalName: String? = "John Appleseed"
</span><span class='line'>  var greeting = "Hello!"
</span><span class='line'>  if let name = optionalName {
</span><span class='line'>  greeting = "Hello, \(name)"
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;strong&gt;switch&lt;/strong&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  let vegetable = "red pepper"
</span><span class='line'>  switch vegetable {
</span><span class='line'>      case "celery":
</span><span class='line'>          let vegetableComment = "Add some raisins and make ants on a log."
</span><span class='line'>      case "cucumber", "watercress":
</span><span class='line'>          let vegetableComment = "That would make a good tea sandwich."
</span><span class='line'>      case let x where x.hasSuffix("pepper"):
</span><span class='line'>          let vegetableComment = "Is it a spicy \(x)?"
</span><span class='line'>      default:
</span><span class='line'>          let vegetableComment = "Everything tastes good in soup."
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;strong&gt;for-in&lt;/strong&gt; in &lt;em&gt;dictionary&lt;/em&gt;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  let interestingNumbers = [
</span><span class='line'>      "Prime": [2, 3, 5, 7, 11, 13],
</span><span class='line'>      "Fibonacci": [1, 1, 2, 3, 5, 8],
</span><span class='line'>      "Square": [1, 4, 9, 16, 25],
</span><span class='line'>  ]
</span><span class='line'>  var largest = 0
</span><span class='line'>  for (kind, numbers) in interestingNumbers {
</span><span class='line'>      for number in numbers {
</span><span class='line'>          if number &gt; largest {
</span><span class='line'>              largest = number
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  largest
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;&lt;strong&gt;while&lt;/strong&gt; and &lt;strong&gt;do-while&lt;/strong&gt;</span></code></pre></td></tr></table></div></figure>
      var n = 2
      while n &lt; 100 {
          n = n * 2
      }
      n</p>

<pre><code>  var m = 2
  do {
      m = m * 2
  } while m &lt; 100
  m
</code></pre>

<p>&#8220;`</p></li>
<li><p>range operators
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  for i in 0..&lt;3 {
</span><span class='line'>      // do something, for 0, 1, 2
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  for i in 0...3 {
</span><span class='line'>  // do something, for 0, 1, 2, 3
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span></code></pre></td></tr></table></div></figure>

<h2><strong>Functions</strong> and <strong>Closures</strong></h2></li>
<li><p>A classic one
<code>
      func greet(name: String, day: String) -&gt; String {
          return "Hello \(name), today is \(day)."
      }
      greet("Bob", "Tuesday")
</code></p></li>
<li>Use a <strong>tuple</strong> as return value
<code>
      func getGasPrices() -&gt; (Double, Double, Double) {
          return (3.59, 3.69, 3.79)
      }
      getGasPrices()
</code></li>
<li>Variable Arguments (varargs)
<code>
      func sumOf(numbers: Int...) -&gt; Int {
          var sum = 0
          for number in numbers {
                  sum += number
              }
          return sum
      }
      sumOf()
      sumOf(42, 597, 12)
</code></li>
<li>Nested functions
<code>
      func returnFifteen() -&gt; Int { // Wrapper function
          var y = 10
          func add() { // Nested function
              y += 5
          }
          add()
          return y
      }
      returnFifteen()
</code></li>
<li>Function as return value (like pointer of function)
<code>
      func makeIncrementer() -&gt; (Int -&gt; Int) {
          func addOne(number: Int) -&gt; Int {
                  return 1 + number
              }
          return addOne
      }
      var increment = makeIncrementer()
      increment(7)
</code></li>
<li>Function as parameter (like Comparator)
<code>
      // Bubble sort with a custom comparator
      func sort(inout list: [Int], sorter: ((Int, Int) -&gt; Bool)) {
          var i : Int = 0
          while i &lt; list.count {
              var j : Int = i + 1
              if j &lt; list.count &amp;&amp; !sorter(list[i], list[j]) {
                  var temp = list[i]
                  list[i] = list[j]
                  list[j] = temp
              }
              i++
          }
      }
      var list = [3, 2, 1]
      func sorter(a : Int, b : Int) -&gt; Bool {
          return a &lt; b
      }
      sort(&amp;list, sorter)
</code></li>
<li>Closure
<code>
      numbers.map({
          (number: Int) -&gt; Int in
          let result = 3 * number
          return result
      })
      // can be simplied to
      numbers.map({ number in 3 * number })
      // sort a array
      var list = [3, 2, 1]
      sort(&amp;list) // NOT sort(list), this function only accept a reference
      var listSorted = sorted(list) // This is OK
</code></li>
</ul>


<h2><strong>Objects</strong> and <strong>Classes</strong></h2>

<ul>
<li><p>A simple class
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Shape {
</span><span class='line'>      var numberOfSides = 0
</span><span class='line'>      func simpleDescription() -&gt; String {
</span><span class='line'>              return &ldquo;A shape with (numberOfSides) sides.&rdquo;
</span><span class='line'>          }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  var shape = Shape()
</span><span class='line'>  shape.numberOfSides = 7
</span><span class='line'>  var shapeDescription = shape.simpleDescription()
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Initializer and its opposite</span></code></pre></td></tr></table></div></figure>
      class NamedShape {
          var numberOfSides: Int = 0
          var name: String</p>

<pre><code>      init(name: String) {
          self.name = name
      }

      deinit {

      }

      func simpleDescription() -&gt; String {
          return "A shape with \(numberOfSides) sides."
      }
  }
</code></pre>

<p>&#8220;`</p></li>
<li><p>Subclass
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Square: NamedShape {
</span><span class='line'>      var sideLength: Double&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      init(sideLength: Double, name: String) {
</span><span class='line'>      self.sideLength = sideLength
</span><span class='line'>      super.init(name: name)
</span><span class='line'>      numberOfSides = 4
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  func area() -&gt; Double {
</span><span class='line'>      return sideLength * sideLength
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  override func simpleDescription() -&gt; String {
</span><span class='line'>      return "A square with sides of length \(sideLength)."
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>  let test = Square(sideLength: 5.2, name: "my test square")
</span><span class='line'>  test.area()
</span><span class='line'>  test.simpleDescription()
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Setter and Getter on properties</span></code></pre></td></tr></table></div></figure>
      class EquilateralTriangle: NamedShape {
          var sideLength: Double = 0.0</p>

<pre><code>      init(sideLength: Double, name: String) {
          self.sideLength = sideLength
          super.init(name: name)
          numberOfSides = 3
      }

      var perimeter: Double {
      get {
              return 3.0 * sideLength
          }
      set {
              sideLength = newValue / 3.0
          }
      }

      override func simpleDescription() -&gt; String {
          return "An equilateral triagle with sides of length \(sideLength)."
      }
  }
  var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
  triangle.perimeter
  triangle.perimeter = 9.9
  triangle.sideLength
</code></pre>

<p>&#8220;`</p></li>
<li>Provide code after before or after setting properties
<code>
      class TriangleAndSquare {
          var triangle: EquilateralTriangle {
              willSet {                                    // Do something after before setting properties
                  square.sideLength = newValue.sideLength
              }
          }
          var square: Square {
              willSet {                                    // Do something after before setting properties
                  triangle.sideLength = newValue.sideLength
              }
          }
          init(size: Double, name: String) {
              square = Square(sideLength: size, name: name)
              triangle = EquilateralTriangle(sideLength: size, name: name)
          }
      }
      var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
      triangleAndSquare.square.sideLength
      triangleAndSquare.triangle.sideLength
      triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
      triangleAndSquare.triangle.sideLength
</code></li>
</ul>


<h2><strong>Enumerations</strong> and <strong>Structures</strong></h2>

<ul>
<li><strong>Enumerations</strong> can have methods
<code>
      enum Rank: Int {
          case Ace = 1
          case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
          case Jack, Queen, King
          func simpleDescription() -&gt; String {
              switch self {
              case .Ace:
                  return "ace"
              case .Jack:
                  return "jack"
              case .Queen:
                  return "queen"
              case .King:
                  return "king"
              default:
                  return String(self.toRaw())
              }
          }
      }
      let ace = Rank.Ace
      let aceRawValue = ace.toRaw()
</code></li>
<li><p>Convert <em>enum</em> between raw values
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  let ace = Rank.Ace
</span><span class='line'>  let aceRawValue = ace.toRaw()
</span><span class='line'>  let aceString = ace.simpleDescription()&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  if let convertedRank = Rank.fromRaw(3) {
</span><span class='line'>  let threeDescription = convertedRank.simpleDescription()
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;strong&gt;Structure&lt;/strong&gt; is similar to &lt;strong&gt;Class&lt;/strong&gt;, but when structures are always copied when they are passed around, while classes are passed by reference.
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  struct Card {
</span><span class='line'>      var rank: Rank
</span><span class='line'>      var suit: Suit
</span><span class='line'>      func simpleDescription() -&gt; String {
</span><span class='line'>          return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  let threeOfSpades = Card(rank: .Three, suit: .Spades)
</span><span class='line'>  let threeOfSpadesDescription = threeOfSpades.simpleDescription()
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;&lt;strong&gt;Structure&lt;/strong&gt; with associated values.</span></code></pre></td></tr></table></div></figure>
      enum ServerResponse {
          case Result(String, String)
          case Error(String)
      }</p>

<pre><code>  let success = ServerResponse.Result("6:00 am", "8:09 pm")
  let failure = ServerResponse.Error("Out of cheese.")

  switch success {
  case let .Result(sunrise, sunset):
      let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
  case let .Error(error):
      let serverResponse = "Failure...  \(error)"
  }
</code></pre>

<p>&#8220;`</p></li>
</ul>


<h2><strong>Protocols</strong> and <strong>Extendsions</strong></h2>

<ul>
<li>A classic <strong>Protocol</strong>.
<code>
      protocol ExampleProtocol {
          var simpleDescription: String { get }
          mutating func adjust()  // "mutating" is needed when a protocol need to modify a structure
      }
</code></li>
<li><p><strong>Classes</strong>, enumerations and structures can all adopt protocols.
&#8220;`
      class SimpleClass: ExampleProtocol {
          var simpleDescription: String = &ldquo;A very simple class.&rdquo;
          var anotherProperty: Int = 69105
          func adjust() {
              simpleDescription += &ldquo;  Now 100% adjusted.&rdquo;
          }
      }
      var a = SimpleClass()
      a.adjust()
      let aDescription = a.simpleDescription</p>

<pre><code>  struct SimpleStructure: ExampleProtocol {
      var simpleDescription: String = "A simple structure"
      mutating func adjust() {
          simpleDescription += " (adjusted)"
      }
  }
  var b = SimpleStructure()
  b.adjust()
  let bDescription = b.simpleDescription
</code></pre>

<p>&#8220;`</p></li>
<li><strong>Extension</strong> to add functionality to an existing type.
<code>
      extension Int: ExampleProtocol {
          var simpleDescription: String {
          return "The number \(self)"
          }
          mutating func adjust() {
              self += 42
          }
      }
      7.simpleDescription
</code></li>
<li>Use <strong>Protocol</strong> as a variable. (Abstracting)
<code>
      let protocolValue: ExampleProtocol = a
      protocolValue.simpleDescription
      // protocolValue.anotherProperty  // Even this is an instance of 'SimpleClass', we cannot access its member not defined in 'ExampleProtocol'
</code></li>
</ul>


<h2><strong>Generics</strong></h2>

<ul>
<li>A classic generic sample.
<code>
      func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; [ItemType] {
          var result = [ItemType]()
          for i in 0..&lt;times {
              result += [item]   // operator += , which are used against Array operands need to be wrapped in []
                                 // means that expand the list by one element
          }
          return result
      }
      repeat("knock", 4)
</code></li>
<li>Generic can also be used on functions and methods, as well as classes, enumerations, and structures.
<code>
      // Reimplement the Swift standard library's optional type
      enum OptionalValue&lt;T&gt; {
          case None
          case Some(T)
      }
      var possibleInteger: OptionalValue&lt;Int&gt; = .None
      possibleInteger = .Some(100)”
</code></li>
<li>Add requirements in <strong>Generic</strong>
<code>
      func anyCommonElements &lt;T, U where T: SequenceType, U: SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, rhs: U) -&gt; Bool {
          for lhsItem in lhs {
              for rhsItem in rhs {
                  if lhsItem == rhsItem {
                      return true
                  }
              }
          }
          return false
      }
      anyCommonElements([1, 2, 3], [3])
</code></li>
</ul>

]]></content>
  </entry>
  
</feed>
