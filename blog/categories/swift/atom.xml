<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-08-24T22:48:31+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift String Operations]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/swift-string-operation/"/>
    <updated>2015-07-02T16:24:46+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/swift-string-operation</id>
    <content type="html"><![CDATA[<p>String operations of Swift seems to be easy to handle, but we should take care of them in development.</p>

<p>For example, this is a common code snippet which stays on the top spot, by searching &lsquo;<strong>swift substring</strong>&rsquo; from <a href="www.google.co.jp">www.google.co.jp</a>.</p>

<pre><code class="swift">extension String {
    public func substring(location:Int, length:Int) -&gt; String! {
        return (self as NSString).substringWithRange(NSMakeRange(location, length))
    }
}
</code></pre>

<p>But, it is not correct. <code>NSString</code>&rsquo;s implementation is based on UTF-16 and handing index for it is just confusing.</p>

<p>Take a look at the following test.</p>

<p><img src="/images/2015_07_02_image01.png" title="Test Failed" alt="IMGAE_A" /></p>

<p>Because index in <code>NSString</code> format is different from index in <code>String</code> format. The text is counted as length 2 in <code>NSString</code>, but only 1 in <code>String</code>.</p>

<p>So using <code>substring</code> in <code>NSString</code> only get half of it, from its binary expression. Then certainly, it cannot be decoded correctly.</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Online Guide</a> has a detail explanation for this problem.</p>

<p>We should use <code>String.Index</code> to handle different byte length of each character, and also decomposed and precomposed characters.</p>

<p>Because <code>String</code> in Swift is implemented as <strong>Unicode Scalar</strong>, or <strong>UTF-32</strong>, is always 4-byte long for each character and it default behaviour can handle composed characters.</p>

<pre><code>    public func substring2(location: Int, length:Int) -&gt; String! {
        assert(location &gt;= 0, "OMG")
        assert(location + length &lt;= count(self), "OMG again")
        var startIndex = self.startIndex
        startIndex = advance(startIndex, location)
        var res = self.substringFromIndex(startIndex)
        var endIndex = advance(startIndex, length)
        return res.substringToIndex(endIndex)
    }
</code></pre>

<p><img src="/images/2015_07_02_image02.png" title="Test Passed" alt="IMAGE_B" /></p>

<p>For further reading about encoding, I recommend this page. <a href="http://www.objc.io/issues/9-strings/unicode/#utf-8">http://www.objc.io/issues/9-strings/unicode/#utf-8</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surrogate Support for Swift's String]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string/"/>
    <updated>2015-07-02T12:41:54+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string</id>
    <content type="html"><![CDATA[<p>String in Swift does not support UTF16 surrogate in default.</p>

<p>From <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Official Guide</a></p>

<blockquote><p>A Unicode scalar is any Unicode code point in the range U+0000 to U+D7FF inclusive or U+E000 to U+10FFFF inclusive. Unicode scalars do not include the Unicode surrogate pair code points, which are the code points in the range U+D800 to U+DFFF inclusive.</p></blockquote>

<p>Therefore, I wrote a support class for it. :)</p>

<hr />

<p><a href="https://github.com/zh-wang/SwiftySurrogate">SwiftSurrogate on Github</a></p>

<p>Now you can decode Swift String from UTF16 surrogate pair like this.</p>

<pre><code class="swift">    var emoji1 = SwiftySurrogate.decodeFromSurrogatePair(surrogatePair: "D83D:DCC9")
    var emoji2 = SwiftySurrogate.decodeFromSurrogatePair(high: 0xD83C, low: 0xDF80)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generics Enum in Swift]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift/"/>
    <updated>2015-05-20T15:27:01+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift</id>
    <content type="html"><![CDATA[<p>If we want handle different data type, according to the result of calling some APIs. We may need the code like this.</p>

<pre><code class="swift">    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(JsonType)
        case Fail(ErrorMsgType)
    } // compile error
</code></pre>

<p>But the code above cannot be compiled.</p>

<pre><code>    // integer overflows when converted from 'Builtin.Int32' to 'Builtin.Int8'MyPlayground.playground:148:6: error: unimplemented IR generation feature non-fixed multi-payload enum layout
    //     enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
</code></pre>

<h3>How can we actually do this</h3>

<p>We can use <code>Container Class</code>.</p>

<pre><code>    class SuccessContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    class ErrorContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(SuccessContainer&lt;JsonType&gt;)
        case Fail(ErrorContainer&lt;ErrorMsgType&gt;)
    }

    // usage

    func GenAPIResponseSuccess&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Success(SuccessContainer&lt;JsonType&gt;(t: json))
    }

    func GenAPIResponseFail&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(ErrorContainer&lt;ErrorMsgType&gt;(t: errorMsg))
    }

    func callbackFromAPI(response: String) -&gt; APIResponse&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess(response) // can be parsed to json
        } else {
            return GenAPIResponseFail(response) // just a plain error msg
        }
    }

    callbackFromAPI("success. I'm Json")
    callbackFromAPI("404 or something else")
</code></pre>

<p>But it is awful to write bunch of code for creating container classes, for each type you need.</p>

<h3>Better Solution?</h3>

<p>Here is a very useful lib. <a href="https://github.com/robrix/Box">https://github.com/robrix/Box</a></p>

<p>It provide a container class called <code>Box</code></p>

<pre><code>    public final class Box&lt;T&gt;: BoxType, Printable {
        /// Initializes a `Box` with the given value.
        public init(_ value: T) {
            self.value = value
        }


        /// Constructs a `Box` with the given `value`.
        public class func unit(value: T) -&gt; Box&lt;T&gt; {
            return Box(value)
        }


        /// The (immutable) value wrapped by the receiver.
        public let value: T

        /// Constructs a new Box by transforming `value` by `f`.
        public func map&lt;U&gt;(@noescape f: T -&gt; U) -&gt; Box&lt;U&gt; {
            return Box&lt;U&gt;(f(value))
        }


        // MARK: Printable

        public var description: String {
            return toString(value)
        }
    }
</code></pre>

<h3>Finally</h3>

<p>We can rewrite above code into this. Much more elegant.</p>

<pre><code>    enum APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        case Success(Box&lt;JsonType&gt;)
        case Fail(Box&lt;ErrorMsgType&gt;)
    }

    func GenAPIResponseSuccess2&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Success(Box&lt;JsonType&gt;(json))
    }

    func GenAPIResponseFail2&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(Box&lt;ErrorMsgType&gt;(errorMsg))
    }

    func callbackFromAPI2(response: String) -&gt; APIResponse2&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess2(response) // can be parsed to json
        } else {
            return GenAPIResponseFail2(response) // just a plain error msg
        }
    }

    callbackFromAPI2("success. I'm Json")
    callbackFromAPI2("404 or something else")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 14 - Optional Chaining]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14/"/>
    <updated>2015-05-12T12:20:35+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Optional Chaining</h3>

<ul>
<li><p><em>Optional chaining</em> is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.</p>

<ul>
<li>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.</li>
<li>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</li>
<li>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</li>
</ul>
</li>
<li><p>Optional Chaining as an Alternative to Forced Unwrapping</p>

<ul>
<li><p>Sample of Forced Unwarpping
        class Person {
            var residence: Residence?
        }</p>

<pre><code>    class Residence {
        var numberOfRooms = 1
    }

    let john = Persion()

    let roomCount = john.residence!.numberOfRooms
    // this triggers a runtime error, because residence maybe nil
</code></pre></li>
<li><p>Optional chaining provides an alternative way to access the value of numberOfRooms.</p>

<pre><code>    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
    // prints "Unable to retrieve the number of rooms.

    // Even numberOfRooms is Int, optional chaining will always return it as Int?
</code></pre></li>
</ul>
</li>
<li><p>Defining Model Classes for Optional Chaining</p>

<pre><code>      class Residence {
          var rooms = Room[]()
          var numberOfRooms: Int {
          return rooms.count
          }
          subscript(i: Int) -&gt; Room {
              return rooms[i]
          }
          func printNumberOfRooms() {
              println("The number of rooms is \(numberOfRooms)")
          }
          var address: Address?
      }

      class Room {
          let name: String
          init(name: String) { self.name = name }
      }

      class Address {
          var buildingName: String?
          var buildingNumber: String?
          var street: String?
          func buildingIdentifier() -&gt; String? {
              if buildingName {
                  return buildingName
              } else if buildingNumber {
                  return buildingNumber
              } else {
                  return nil
              }
          }
      }
</code></pre></li>
</ul>


<!-- more -->


<ul>
<li><p>Calling Properties Through Optional Chaining</p>

<ul>
<li><p>It is the same as above</p>

<pre><code>    let john = Person()
    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
</code></pre></li>
</ul>
</li>
<li><p>Calling Methods Through Optional Chaining</p>

<pre><code>      func printNumberOfRooms() {
          println("The number of rooms is \(numberOfRooms)")
      }

      “if john.residence?.printNumberOfRooms() {
          println("It was possible to print the number of rooms.")
      } else {
          println("It was not possible to print the number of rooms.")
      }
      // prints "It was not possible to print the number of rooms.
</code></pre></li>
<li><p>Calling Subscripts Through Optional Chaining</p>

<pre><code>      if let firstRoomName = john.residence?[0].name {
          println("The first room name is \(firstRoomName).")
      } else {
          println("Unable to retrieve the first room name.")
      }
      // prints "Unable to retrieve the first room name.
</code></pre></li>
<li><p>Linking Multiple Levels of Chaining</p>

<ul>
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li><p>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</p>

<pre><code>    “if let johnsStreet = john.residence?.address?.street {
        println("John's street name is \(johnsStreet).")
    } else {
        println("Unable to retrieve the address.")
    }
    // prints "Unable to retrieve the address.”
</code></pre></li>
</ul>
</li>
<li><p>Chaining on Methods With Optional Return Values</p>

<pre><code>      if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
          println("John's building identifier is \(buildingIdentifier).")
      }
      // prints "John's building identifier is The Larches.

      “if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
          println("John's uppercase building identifier is \(upper).")
      }
      // prints "John's uppercase building identifier is THE LARCHES.”
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 13 - ARC]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13/"/>
    <updated>2015-01-08T10:13:30+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Automatic Reference Counting</h3>

<ul>
<li><p>Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</p></li>
<li><p>Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</p></li>
<li><p>How ARC Works</p>

<p>  To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The reference is called a “strong“ reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</p></li>
<li><p>ARC in Action</p></li>
</ul>


<pre><code class="swift">        class Person {
            let name: String
            init(name: String) {
                self.name = name
                println("\(name) is being initialized")
            }
            deinit {
                println("\(name) is being deinitialized")
            }
        }

        // The next code snippet defines three variables of type Person?, which are used to set up multiple references to a new Person instance in subsequent code snippets. Because these variables are of an optional type (Person?, not Person), they are automatically initialized with a value of nil, and do not currently reference a Person instance.
        var reference1: Person?
        var reference2: Person?
        var reference3: Person?

        reference2 = reference1
        reference3 = reference1

        reference1 = nil
        reference2 = nil

        reference3 = nil
        // prints "John Appleseed is being deinitialized"
</code></pre>

<!-- more -->


<ul>
<li><p>Strong Reference Cycles Between Class Instances</p>

<p>  It is possible to write code in which an instance of a class never gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Person {
</span><span class='line'>      let name: String
</span><span class='line'>      init(name: String) { self.name = name }
</span><span class='line'>      var apartment: Apartment?
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Apartment {
</span><span class='line'>  let number: Int
</span><span class='line'>  init(number: Int) { self.number = number }
</span><span class='line'>  var tenant: Person?
</span><span class='line'>  deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Person?
</span><span class='line'>  var number73: Apartment?
</span><span class='line'>
</span><span class='line'>  john = Person(name: "John Appleseed")
</span><span class='line'>  number73 = Apartment(number: 73)
</span><span class='line'>
</span><span class='line'>  john!.apartment = number73
</span><span class='line'>  number73!.tenant = john
</span><span class='line'>  // The strong references between the Person instance and the Apartment instance remain and cannot be broken.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles Between Class Instances&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references. Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Weak References&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Weak references must be declared as variables, to indicate that their value can change at runtime. A weak reference cannot be declared as a constant.</span></code></pre></td></tr></table></div></figure>
      class Person {
          let name: String
          init(name: String) { self.name = name }
          var apartment: Apartment?
          deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
      }</p>

<pre><code>  class Apartment {
      let number: Int
      init(number: Int) { self.number = number }
      weak var tenant: Person?
      deinit { println("Apartment #\(number) is being deinitialized") }
  }

  var john: Person?
  var number73: Apartment?

  john = Person(name: "John Appleseed")
  number73 = Apartment(number: 73)

  john!.apartment = number73
  number73!.tenant = john

  john = nil
  // prints "John Appleseed is being deinitialized"
  // The Person instance still has a strong reference to the Apartment instance, but the Apartment instance now has a weak reference to the Person instance. This means that when you break the strong reference held by the john variables, there are no more strong references to the Person instance.
  // Because there are no more strong references to the Person instance, it is deallocated.

  number73 = nil
  // prints "Apartment #73 is being deinitialized"
  // The only remaining strong reference to the Apartment instance is from the number73 variable. If you break that strong reference, there are no more strong references to the Apartment instance.
  // Because there are no more strong references to the Apartment instance, it too is deallocated.
</code></pre>

<p>&#8220;`</p></li>
<li><p>Unowned References</p>

<p>  Like weak references, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is assumed to always have a value. Because of this, an unowned reference is always defined as a non-optional type. You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.</p>

<p>  Because an unowned reference is non-optional, you don’t need to unwrap the unowned reference each time it is used. An unowned reference can always be accessed directly. However, ARC cannot set the reference to nil when the instance it refers to is deallocated, because variables of a non-optional type cannot be set to nil.</p>

<p>  If you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error. Use unowned references only when you are sure that the reference will always refer to an instance.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Customer {
</span><span class='line'>      let name: String
</span><span class='line'>      var card: CreditCard?
</span><span class='line'>      init(name: String) {
</span><span class='line'>          self.name = name
</span><span class='line'>      }
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class CreditCard {
</span><span class='line'>  let number: UInt64
</span><span class='line'>  unowned let customer: Customer
</span><span class='line'>  init(number: UInt64, customer: Customer) {
</span><span class='line'>      self.number = number
</span><span class='line'>      self.customer = customer
</span><span class='line'>  }
</span><span class='line'>  deinit { println("Card #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Customer?
</span><span class='line'>
</span><span class='line'>  john = Customer(name: "John Appleseed")
</span><span class='line'>  john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</span><span class='line'>
</span><span class='line'>  john = nil
</span><span class='line'>  // prints "John Appleseed is being deinitialized"
</span><span class='line'>  // prints "Card #1234567890123456 is being deinitialized"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Unowned References and Implicitly Unwrapped Optional Properties&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Person&lt;/em&gt; and &lt;em&gt;Apartment&lt;/em&gt; example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Customer&lt;/em&gt; and &lt;em&gt;CreditCard&lt;/em&gt; example shows a situation where one property that is allowed to be nil and another property that cannot be nil have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  However, there is a third scenario, in which both properties should always have a value, and neither property should ever be nil once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</span></code></pre></td></tr></table></div></figure>
      class Country {
          let name: String
          let capitalCity: City!
          init(name: String, capitalName: String) {
              self.name = name
              self.capitalCity = City(name: capitalName, country: self)
          }
      }</p>

<pre><code>  class City {
      let name: String
      unowned let country: Country
      init(name: String, country: Country) {
          self.name = name
          self.country = country
      }
  }

  var country = Country(name: "Canada", capitalName: "Ottawa")
  println("\(country.name)'s capital city is called \(country.capitalCity.name)")
  // prints "Canada's capital city is called Ottawa"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Strong Reference Cycles for Closures</p>

<p>  A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // The example below shows how you can create a strong reference cycle when using a closure that references self. This example defines a class called HTMLElement, which provides a simple model for an individual element within an HTML document:
</span><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  // The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // The paragraph variable above is defined as an optional HTMLElement, so that it can be set to nil below to demonstrate the presence of a strong reference cycle.
</span><span class='line'>  var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints "&lt;p&gt;hello, world&lt;/p&gt;"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  Unfortunately, the HTMLElement class, as written above, creates a strong reference cycle between an HTMLElement instance and the closure used for its default asHTML. ( Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance. )
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  paragraph = nil
</span><span class='line'>  // If you set the paragraph variable to nil and break its strong reference to the HTMLElement instance, neither the HTMLElement instance nor its closure are deallocated, because of the strong reference cycle
</span><span class='line'>  // Note that the message in the HTMLElement deinitializer is not printed, which shows that the HTMLElement instance is not deallocated.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles for Closures&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  * Swift requires you to write self.someProperty or self.someMethod (rather than just someProperty or someMethod) whenever you refer to a member of self within a closure. This helps you remember that it’s possible to capture self by accident.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Defining a Capture List&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self or someInstance). These pairings are written within a pair of square braces, separated by commas.</span></code></pre></td></tr></table></div></figure>
      lazy var someClosure: (Int, String) -> String = {
          [unowned self] (index: Int, stringToProcess: String) -> String in
          // closure body goes here
      }</p>

<p>  If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword:</p>

<pre><code>  lazy var someClosure: () -&gt; String = {
      [unowned self] in
      // closure body goes here
  }
</code></pre>

<p>&#8220;`</p></li>
<li>Weak and Unowned References

<ul>
<li>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</li>
<li>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</li>
<li><p>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      [unowned self] in
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  var paragraph: HTMLElement? = HTMLElement(name: &ldquo;p&rdquo;, text: &ldquo;hello, world&rdquo;)
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints &ldquo;&lt;p&gt;hello, world&lt;/p&gt;&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  paragraph = nil
</span><span class='line'>  // prints &ldquo;p is being deinitialized&rdquo;</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
