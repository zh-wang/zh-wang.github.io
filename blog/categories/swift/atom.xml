<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-02-21T22:05:31+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 13 - ARC]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13/"/>
    <updated>2015-01-08T10:13:30+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/08/learning-swift-part-13</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Automatic Reference Counting</h3>

<ul>
<li><p>Swift uses Automatic Reference Counting (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you do not need to think about memory management yourself.</p></li>
<li><p>Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</p></li>
<li><p>How ARC Works</p>

<p>  To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a strong reference to the instance. The reference is called a “strong“ reference because it keeps a firm hold on that instance, and does not allow it to be deallocated for as long as that strong reference remains.</p></li>
<li><p>ARC in Action</p></li>
</ul>


<pre><code class="swift">        class Person {
            let name: String
            init(name: String) {
                self.name = name
                println("\(name) is being initialized")
            }
            deinit {
                println("\(name) is being deinitialized")
            }
        }

        // The next code snippet defines three variables of type Person?, which are used to set up multiple references to a new Person instance in subsequent code snippets. Because these variables are of an optional type (Person?, not Person), they are automatically initialized with a value of nil, and do not currently reference a Person instance.
        var reference1: Person?
        var reference2: Person?
        var reference3: Person?

        reference2 = reference1
        reference3 = reference1

        reference1 = nil
        reference2 = nil

        reference3 = nil
        // prints "John Appleseed is being deinitialized"
</code></pre>

<ul>
<li><p>Strong Reference Cycles Between Class Instances</p>

<p>  It is possible to write code in which an instance of a class never gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Person {
</span><span class='line'>      let name: String
</span><span class='line'>      init(name: String) { self.name = name }
</span><span class='line'>      var apartment: Apartment?
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Apartment {
</span><span class='line'>  let number: Int
</span><span class='line'>  init(number: Int) { self.number = number }
</span><span class='line'>  var tenant: Person?
</span><span class='line'>  deinit { println("Apartment #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Person?
</span><span class='line'>  var number73: Apartment?
</span><span class='line'>
</span><span class='line'>  john = Person(name: "John Appleseed")
</span><span class='line'>  number73 = Apartment(number: 73)
</span><span class='line'>
</span><span class='line'>  john!.apartment = number73
</span><span class='line'>  number73!.tenant = john
</span><span class='line'>  // The strong references between the Person instance and the Apartment instance remain and cannot be broken.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles Between Class Instances&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references. Use a weak reference whenever it is valid for that reference to become nil at some point during its lifetime. Conversely, use an unowned reference when you know that the reference will never be nil once it has been set during initialization.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Weak References&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Weak references must be declared as variables, to indicate that their value can change at runtime. A weak reference cannot be declared as a constant.</span></code></pre></td></tr></table></div></figure>
      class Person {
          let name: String
          init(name: String) { self.name = name }
          var apartment: Apartment?
          deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
      }</p>

<pre><code>  class Apartment {
      let number: Int
      init(number: Int) { self.number = number }
      weak var tenant: Person?
      deinit { println("Apartment #\(number) is being deinitialized") }
  }

  var john: Person?
  var number73: Apartment?

  john = Person(name: "John Appleseed")
  number73 = Apartment(number: 73)

  john!.apartment = number73
  number73!.tenant = john

  john = nil
  // prints "John Appleseed is being deinitialized"
  // The Person instance still has a strong reference to the Apartment instance, but the Apartment instance now has a weak reference to the Person instance. This means that when you break the strong reference held by the john variables, there are no more strong references to the Person instance.
  // Because there are no more strong references to the Person instance, it is deallocated.

  number73 = nil
  // prints "Apartment #73 is being deinitialized"
  // The only remaining strong reference to the Apartment instance is from the number73 variable. If you break that strong reference, there are no more strong references to the Apartment instance.
  // Because there are no more strong references to the Apartment instance, it too is deallocated.
</code></pre>

<p>&#8220;`</p></li>
<li><p>Unowned References</p>

<p>  Like weak references, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is assumed to always have a value. Because of this, an unowned reference is always defined as a non-optional type. You indicate an unowned reference by placing the unowned keyword before a property or variable declaration.</p>

<p>  Because an unowned reference is non-optional, you don’t need to unwrap the unowned reference each time it is used. An unowned reference can always be accessed directly. However, ARC cannot set the reference to nil when the instance it refers to is deallocated, because variables of a non-optional type cannot be set to nil.</p>

<p>  If you try to access an unowned reference after the instance that it references is deallocated, you will trigger a runtime error. Use unowned references only when you are sure that the reference will always refer to an instance.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Customer {
</span><span class='line'>      let name: String
</span><span class='line'>      var card: CreditCard?
</span><span class='line'>      init(name: String) {
</span><span class='line'>          self.name = name
</span><span class='line'>      }
</span><span class='line'>      deinit { println(&ldquo;(name) is being deinitialized&rdquo;) }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class CreditCard {
</span><span class='line'>  let number: UInt64
</span><span class='line'>  unowned let customer: Customer
</span><span class='line'>  init(number: UInt64, customer: Customer) {
</span><span class='line'>      self.number = number
</span><span class='line'>      self.customer = customer
</span><span class='line'>  }
</span><span class='line'>  deinit { println("Card #\(number) is being deinitialized") }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var john: Customer?
</span><span class='line'>
</span><span class='line'>  john = Customer(name: "John Appleseed")
</span><span class='line'>  john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
</span><span class='line'>
</span><span class='line'>  john = nil
</span><span class='line'>  // prints "John Appleseed is being deinitialized"
</span><span class='line'>  // prints "Card #1234567890123456 is being deinitialized"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Unowned References and Implicitly Unwrapped Optional Properties&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Person&lt;/em&gt; and &lt;em&gt;Apartment&lt;/em&gt; example shows a situation where two properties, both of which are allowed to be nil, have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  The &lt;em&gt;Customer&lt;/em&gt; and &lt;em&gt;CreditCard&lt;/em&gt; example shows a situation where one property that is allowed to be nil and another property that cannot be nil have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  However, there is a third scenario, in which both properties should always have a value, and neither property should ever be nil once initialization is complete. In this scenario, it is useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class.</span></code></pre></td></tr></table></div></figure>
      class Country {
          let name: String
          let capitalCity: City!
          init(name: String, capitalName: String) {
              self.name = name
              self.capitalCity = City(name: capitalName, country: self)
          }
      }</p>

<pre><code>  class City {
      let name: String
      unowned let country: Country
      init(name: String, country: Country) {
          self.name = name
          self.country = country
      }
  }

  var country = Country(name: "Canada", capitalName: "Ottawa")
  println("\(country.name)'s capital city is called \(country.capitalCity.name)")
  // prints "Canada's capital city is called Ottawa"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Strong Reference Cycles for Closures</p>

<p>  A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // The example below shows how you can create a strong reference cycle when using a closure that references self. This example defines a class called HTMLElement, which provides a simple model for an individual element within an HTML document:
</span><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;      let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  // The asHTML property is declared as a lazy property, because it is only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that asHTML is a lazy property means that you can refer to self within the default closure, because the lazy property will not be accessed until after initialization has been completed and self is known to exist.
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // The paragraph variable above is defined as an optional HTMLElement, so that it can be set to nil below to demonstrate the presence of a strong reference cycle.
</span><span class='line'>  var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints "&lt;p&gt;hello, world&lt;/p&gt;"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  Unfortunately, the HTMLElement class, as written above, creates a strong reference cycle between an HTMLElement instance and the closure used for its default asHTML. ( Even though the closure refers to self multiple times, it only captures one strong reference to the HTMLElement instance. )
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  paragraph = nil
</span><span class='line'>  // If you set the paragraph variable to nil and break its strong reference to the HTMLElement instance, neither the HTMLElement instance nor its closure are deallocated, because of the strong reference cycle
</span><span class='line'>  // Note that the message in the HTMLElement deinitializer is not printed, which shows that the HTMLElement instance is not deallocated.
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Resolving Strong Reference Cycles for Closures&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  * Swift requires you to write self.someProperty or self.someMethod (rather than just someProperty or someMethod) whenever you refer to a member of self within a closure. This helps you remember that it’s possible to capture self by accident.&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Defining a Capture List&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self or someInstance). These pairings are written within a pair of square braces, separated by commas.</span></code></pre></td></tr></table></div></figure>
      lazy var someClosure: (Int, String) -> String = {
          [unowned self] (index: Int, stringToProcess: String) -> String in
          // closure body goes here
      }</p>

<p>  If a closure does not specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the in keyword:</p>

<pre><code>  lazy var someClosure: () -&gt; String = {
      [unowned self] in
      // closure body goes here
  }
</code></pre>

<p>&#8220;`</p></li>
<li>Weak and Unowned References

<ul>
<li>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</li>
<li>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</li>
<li><p>If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class HTMLElement {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let name: String
</span><span class='line'>  let text: String?
</span><span class='line'>
</span><span class='line'>  lazy var asHTML: () -&gt; String = {
</span><span class='line'>      [unowned self] in
</span><span class='line'>      if let text = self.text {
</span><span class='line'>          return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
</span><span class='line'>      } else {
</span><span class='line'>          return "&lt;\(self.name) /&gt;"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  init(name: String, text: String? = nil) {
</span><span class='line'>      self.name = name
</span><span class='line'>      self.text = text
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  deinit {
</span><span class='line'>      println("\(name) is being deinitialized")
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  var paragraph: HTMLElement? = HTMLElement(name: &ldquo;p&rdquo;, text: &ldquo;hello, world&rdquo;)
</span><span class='line'>  println(paragraph!.asHTML())
</span><span class='line'>  // prints &ldquo;&lt;p&gt;hello, world&lt;/p&gt;&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  paragraph = nil
</span><span class='line'>  // prints &ldquo;p is being deinitialized&rdquo;</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 12 - Deinitialization]]></title>
    <link href="http://zh-wang.github.io/blog/2015/01/06/learning-swift-part-12/"/>
    <updated>2015-01-06T19:34:40+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/01/06/learning-swift-part-12</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Deinitialization</h3>

<ul>
<li><p>How Deinitialization Works</p>

<p>  Swift automatically deallocates your instances when they are no longer needed, to free up resources. Swift handles the memory management of instances through automatic reference counting (ARC), as described in Automatic Reference Counting.</p></li>
<li><p>Deinitializers in Action, a sample of Bank operations</p></li>
</ul>


<pre><code class="swift">    struct Bank {
        static var coinsInBank = 10_000
        static func vendCoins(var numberOfCoinsToVend: Int) -&gt; Int {
            numberOfCoinsToVend = min(numberOfCoinsToVend, coinsInBank)
            coinsInBank -= numberOfCoinsToVend
            return numberOfCoinsToVend
        }
        static func receiveCoins(coins: Int) {
            coinsInBank += coins
        }
    }

    class Player {
        var coinsInPurse: Int
        init(coins: Int) {
            coinsInPurse = Bank.vendCoins(coins)
        }
        func winCoins(coins: Int) {
            coinsInPurse += Bank.vendCoins(coins)
        }
        deinit {
            Bank.receiveCoins(coinsInPurse)
        }
    }

    var playerOne: Player? = Player(coins: 100)
    println("A new player has joined the game with \(playerOne!.coinsInPurse) coins")
    // prints "A new player has joined the game with 100 coins"
    println("There are now \(Bank.coinsInBank) coins left in the bank")
    // prints "There are now 9900 coins left in the bank"

    playerOne!.winCoins(2_000)
    println("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")
    // prints "PlayerOne won 2000 coins &amp; now has 2100 coins"
    println("The bank now only has \(Bank.coinsInBank) coins left")
    // prints "The bank now only has 7900 coins left"

    playerOne = nil
    println("PlayerOne has left the game")
    // prints "PlayerOne has left the game"
    println("The bank now has \(Bank.coinsInBank) coins")
    // prints "The bank now has 10000 coins"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 11 - Inheritance]]></title>
    <link href="http://zh-wang.github.io/blog/2014/11/20/learning-swift-part-11/"/>
    <updated>2014-11-20T19:10:05+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/11/20/learning-swift-part-11</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Inheritance</h3>

<ul>
<li>A base class, Vehicle
<code>
      class Vehicle {
          var currentSpeed = 0.0
          var description: String {
                  return "traveling at \(currentSpeed) miles per hour"
          }
          func makeNoise() {
                  // do nothing - an arbitrary vehicle doesn't necessarily make a noise
          }
      }
</code></li>
<li><p>Subclass, Bicycle and Tandem
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Bicycle: Vehicle {
</span><span class='line'>      var hasBasket = false
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Tandem: Bicycle {
</span><span class='line'>  var currentNumberOfPassengers = 0
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  let tandem = Tandem()
</span><span class='line'>  tandem.hasBasket = true
</span><span class='line'>  tandem.currentNumberOfPassengers = 2
</span><span class='line'>  tandem.currentSpeed = 22.0
</span><span class='line'>  println("Tandem: \(tandem.description)")
</span><span class='line'>  // Tandem: traveling at 22.0 miles per hour
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;!-- more --&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Overriding&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;A subclass can provide its own custom implementation of an instance method, class method, instance property, class property, or subscript that it would otherwise inherit from a superclass. This is known as overriding.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the override keyword. Doing so clarifies that you intend to provide an override and have not provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the override keyword are diagnosed as an error when your code is compiled.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;The override keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Accessing Superclass Methods, Properties, and Subscripts&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;An overridden method named someMethod can call the superclass version of someMethod by calling super.someMethod() within the overriding method implementation.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;An overridden property called someProperty can access the superclass version of someProperty as super.someProperty within the overriding getter or setter implementation.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;An overridden subscript for someIndex can access the superclass version of the same subscript as super[someIndex] from within the overriding subscript implementation.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Overriding Methods</span></code></pre></td></tr></table></div></figure>
      class Train: Vehicle {
          override func makeNoise() {
              println(&ldquo;Choo Choo&rdquo;)
          }
      }</p>

<pre><code>  let train = Train()
  train.makeNoise()
  // prints "Choo Choo"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Overriding Properties</p>

<ul>
<li>You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</li>
</ul>
</li>
<li><p>Overriding Property Getters and Setters</p>

<ul>
<li>You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You cannot, however, present an inherited read-write property as a read-only property.</li>
<li><p>If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning super.someProperty from the getter, where someProperty is the name of the property you are overriding.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class Car: Vehicle {
</span><span class='line'>      var gear = 1
</span><span class='line'>      override var description: String {
</span><span class='line'>          return super.description + &ldquo; in gear (gear)&rdquo;
</span><span class='line'>      }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  let car = Car()
</span><span class='line'>  car.currentSpeed = 25.0
</span><span class='line'>  car.gear = 3
</span><span class='line'>  println(&ldquo;Car: (car.description)&rdquo;)
</span><span class='line'>  // Car: traveling at 25.0 miles per hour in gear 3</span></code></pre></td></tr></table></div></figure></p></li>
</ul>
</li>
<li><p>Overriding Property Observers
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class AutomaticCar: Car {
</span><span class='line'>      override var currentSpeed: Double {
</span><span class='line'>          didSet {
</span><span class='line'>              gear = Int(currentSpeed / 10.0) + 1
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let automatic = AutomaticCar()
</span><span class='line'>  automatic.currentSpeed = 35.0
</span><span class='line'>  println("AutomaticCar: \(automatic.description)")
</span><span class='line'>  // AutomaticCar: traveling at 35.0 miles per hour in gear 4
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Preventing Overrides
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;You can prevent a method, property, or subscript from being overridden by marking it as final. Do this by writing the final modifier before the method, property, or subscript’s introducer keyword (such as final var, final func, final class func, and final subscript).&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.&lt;/li&gt;
</span><span class='line'>&lt;li&gt;You can mark an entire class as final by writing the final modifier before the class keyword in its class definition (final class). Any attempt to subclass a final class is reported as a compile-time error.&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Learning Swift Part 10 - Methods]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-10/"/&gt;
</span><span class='line'>&lt;updated&gt;2014-10-24T18:51:55+09:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-10&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h2&gt;===== Full Notes =====&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;Methods&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Instance Methods</span></code></pre></td></tr></table></div></figure>swift
      class Counter {
          var count = 0
          func increment() {
              count++
          }
          func incrementBy(amount: Int) {
              count += amount
          }
          func reset() {
              count = 0
          }
      }</p>

<pre><code>  let counter = Counter()
  // the initial counter value is 0
  counter.increment()
  // the counter's value is now 1
  counter.incrementBy(5)
  // the counter's value is now 6
  counter.reset()
  // the counter's value is now 0
</code></pre>

<p>&#8220;`</p></li>
<li><p>Local and External Parameter Names for Methods<br/>
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // Specifically, Swift gives the first parameter name in a method a local parameter name by default, and gives the second and subsequent parameter names both local and external parameter names by default.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  class Counter {
</span><span class='line'>  var count: Int = 0
</span><span class='line'>  func incrementBy(amount: Int, numberOfTimes: Int) {
</span><span class='line'>      count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  let counter = Counter()
</span><span class='line'>  counter.incrementBy(5, numberOfTimes: 3)
</span><span class='line'>  // counter value is now 15
</span><span class='line'>
</span><span class='line'>  // It is behaved as the same as putting a '#' symbol before the name
</span><span class='line'>
</span><span class='line'>  func incrementBy(amount: Int, #numberOfTimes: Int) {
</span><span class='line'>  count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  // This will not allow external name
</span><span class='line'>
</span><span class='line'>  func incrementBy(amount: Int, _ : Int) {
</span><span class='line'>  count += amount * numberOfTimes
</span><span class='line'>  }
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;!-- more --&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;The self Property</span></code></pre></td></tr></table></div></figure>
      func increment() {
          self.count++
      }</p>

<pre><code>  struct Point {
      var x = 0.0, y = 0.0
      func isToTheRightOfX(x: Double) -&gt; Bool {
          return self.x &gt; x
      }
  }
  let somePoint = Point(x: 4.0, y: 5.0)
  if somePoint.isToTheRightOfX(1.0) {
      println("This point is to the right of the line where x == 1.0")
  }
  // prints "This point is to the right of the line where x == 1.0"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Modifying Value Types from Within Instance Methods
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct Point {
</span><span class='line'>      var x = 0.0, y = 0.0
</span><span class='line'>      mutating func moveByX(deltaX: Double, y deltaY: Double) {
</span><span class='line'>          x += deltaX
</span><span class='line'>          y += deltaY
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  var somePoint = Point(x: 1.0, y: 1.0)
</span><span class='line'>  somePoint.moveByX(2.0, y: 3.0)
</span><span class='line'>  println(&ldquo;The point is now at ((somePoint.x), (somePoint.y))&rdquo;)
</span><span class='line'>  // prints &ldquo;The point is now at (3.0, 4.0)&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  // constant instance's properties cannot be modified
</span><span class='line'>
</span><span class='line'>  let fixedPoint = Point(x: 3.0, y: 3.0)
</span><span class='line'>  fixedPoint.moveByX(2.0, y: 3.0)
</span><span class='line'>  // this will report an error
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Assigning to self Within a Mutating Method</span></code></pre></td></tr></table></div></figure>
      struct Point {
          var x = 0.0, y = 0.0
          mutating func moveByX(deltaX: Double, y deltaY: Double) {
              self = Point(x: x + deltaX, y: y + deltaY)
          }
      }</p>

<pre><code>  enum TriStateSwitch {
      case Off, Low, High
      mutating func next() {
          switch self {
          case Off:
              self = Low
          case Low:
              self = High
          case High:
              self = Off
          }
      }
  }
  var ovenLight = TriStateSwitch.Low
  ovenLight.next()
  // ovenLight is now equal to .High
  ovenLight.next()
  // ovenLight is now equal to .Off
</code></pre>

<p>&#8220;`</p></li>
<li><p>Type Methods
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  class SomeClass {
</span><span class='line'>      class func someTypeMethod() {
</span><span class='line'>          // type method implementation goes here
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  SomeClass.someTypeMethod()&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  // Within the body of a type method, the implicit self property refers to the type itself, rather than an instance of that type. For structures and enumerations, this means that you can use self to disambiguate between static properties and static method parameters, just as you do for instance properties and instance method parameters.
</span><span class='line'>
</span><span class='line'>  struct LevelTracker {
</span><span class='line'>  static var highestUnlockedLevel = 1
</span><span class='line'>  static func unlockLevel(level: Int) {
</span><span class='line'>      if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }
</span><span class='line'>  }
</span><span class='line'>  static func levelIsUnlocked(level: Int) -&gt; Bool {
</span><span class='line'>      return level &lt;= highestUnlockedLevel
</span><span class='line'>  }
</span><span class='line'>  var currentLevel = 1
</span><span class='line'>  mutating func advanceToLevel(level: Int) -&gt; Bool {
</span><span class='line'>      if LevelTracker.levelIsUnlocked(level) {
</span><span class='line'>          currentLevel = level
</span><span class='line'>          return true
</span><span class='line'>      } else {
</span><span class='line'>          return false
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  class Player {
</span><span class='line'>  var tracker = LevelTracker()
</span><span class='line'>  let playerName: String
</span><span class='line'>  func completedLevel(level: Int) {
</span><span class='line'>      LevelTracker.unlockLevel(level + 1)
</span><span class='line'>      tracker.advanceToLevel(level + 1)
</span><span class='line'>  }
</span><span class='line'>  init(name: String) {
</span><span class='line'>      playerName = name
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var player = Player(name: "Argyrios")
</span><span class='line'>  player.completedLevel(1)
</span><span class='line'>  println("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")
</span><span class='line'>  // prints "highest unlocked level is now 2"
</span><span class='line'>
</span><span class='line'>  player = Player(name: "Beto")
</span><span class='line'>  if player.tracker.advanceToLevel(6) {
</span><span class='line'>  println("player is now on level 6")
</span><span class='line'>  } else {
</span><span class='line'>  println("level 6 has not yet been unlocked")
</span><span class='line'>  }
</span><span class='line'>  // prints "level 6 has not yet been unlocked"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>]]&gt;&lt;/content&gt;
</span><span class='line'>  &lt;/entry&gt;
</span><span class='line'>  
</span><span class='line'>  &lt;entry&gt;
</span><span class='line'>&lt;title type="html"&gt;&lt;![CDATA[Learning Swift Part 9 - Properties, Subscripts]]&gt;&lt;/title&gt;
</span><span class='line'>&lt;link href="http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-9/"/&gt;
</span><span class='line'>&lt;updated&gt;2014-10-24T18:46:57+09:00&lt;/updated&gt;
</span><span class='line'>&lt;id&gt;http://zh-wang.github.io/blog/2014/10/24/learning-swift-part-9&lt;/id&gt;
</span><span class='line'>&lt;content type="html"&gt;&lt;![CDATA[&lt;h2&gt;===== Full Notes =====&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;Properties&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;Stored Properties
</span><span class='line'>&lt;code&gt;swift
</span><span class='line'>  struct FixedLengthRange {
</span><span class='line'>      var firstValue: Int
</span><span class='line'>      let length: Int
</span><span class='line'>  }
</span><span class='line'>  var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
</span><span class='line'>  // the range represents integer values 0, 1, and 2
</span><span class='line'>  rangeOfThreeItems.firstValue = 6
</span><span class='line'>  // the range now represents integer values 6, 7, and 8
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Stored Properties of Constant Structure Instances
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
</span><span class='line'>  // this range represents integer values 0, 1, 2, and 3
</span><span class='line'>  rangeOfFourItems.firstValue = 6
</span><span class='line'>  // this will report an error, even though firstValue is a variable property
</span><span class='line'>  // This behavior is due to structures being value types. When an instance of a value type is marked as a constant, so are all of its properties.
</span><span class='line'>  // The same is not true for classes, which are reference types. If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties.
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Lazy Stored Properties&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the lazy modifier before its declaration.</span></code></pre></td></tr></table></div></figure>
      class DataImporter {
          /<em>
          DataImporter is a class to import data from an external file.
          The class is assumed to take a non-trivial amount of time to initialize.
          </em>/
          var fileName = &ldquo;data.txt&rdquo;
          // the DataImporter class would provide data importing functionality here
      }</p>

<pre><code>  class DataManager {
      lazy var importer = DataImporter()
      var data = [String]()
      // the DataManager class would provide data management functionality here
  }

  let manager = DataManager()
  manager.data.append("Some data")
  manager.data.append("Some more data")
  // the DataImporter instance for the importer property has not yet been created

  println(manager.importer.fileName)
  // the DataImporter instance for the importer property has now been created
  // prints "data.txt"
</code></pre>

<p>&#8220;`</p></li>
</ul>


<!-- more -->


<ul>
<li><p>Stored Properties and Instance Variables</p></li>
<li><p>Computed Properties
<code>
      struct Point {
          var x = 0.0, y = 0.0
      }
      struct Size {
          var width = 0.0, height = 0.0
      }
      struct Rect {
          var origin = Point()
          var size = Size()
          var center: Point {
              get {
                  let centerX = origin.x + (size.width / 2)
                  let centerY = origin.y + (size.height / 2)
                  return Point(x: centerX, y: centerY)
              }
              set(newCenter) {
                  origin.x = newCenter.x - (size.width / 2)
                  origin.y = newCenter.y - (size.height / 2)
              }
          }
      }
      var square = Rect(origin: Point(x: 0.0, y: 0.0),
          size: Size(width: 10.0, height: 10.0))
      let initialSquareCenter = square.center
      square.center = Point(x: 15.0, y: 15.0)
      println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
      // prints "square.origin is now at (10.0, 10.0)"
</code></p></li>
<li><p>Read-Only Computed Properties</p>

<p>  A computed property with a getter but no setter is known as a read-only computed property. A read-only computed property always returns a value, and can be accessed through dot syntax, but cannot be set to a different value.
<code>
      struct Cuboid {
          var width = 0.0, height = 0.0, depth = 0.0
          var volume: Double {
              return width * height * depth
          }
      }
      let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
      println("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")
      // prints "the volume of fourByFiveByTwo is 40.0"
</code></p></li>
<li>Property Observers
<code>
      class StepCounter {
          var totalSteps: Int = 0 {
              willSet(newTotalSteps) {
                  println("About to set totalSteps to \(newTotalSteps)")
              }
              didSet {
                  if totalSteps &gt; oldValue  {
                      println("Added \(totalSteps - oldValue) steps")
                  }
              }
          }
      }
      let stepCounter = StepCounter()
      stepCounter.totalSteps = 200
      // About to set totalSteps to 200
      // Added 200 steps
      stepCounter.totalSteps = 360
      // About to set totalSteps to 360
      // Added 160 steps
      stepCounter.totalSteps = 896
      // About to set totalSteps to 896
      // Added 536 steps
</code></li>
<li><p>Global and Local Variables</p></li>
<li><p>Type Properties (Like C static variables)
<code>
      struct SomeStructure {
          static var storedTypeProperty = "Some value."
          static var computedTypeProperty: Int {
              // return an Int value here
          }
      }
      enum SomeEnumeration {
          static var storedTypeProperty = "Some value."
          static var computedTypeProperty: Int {
              // return an Int value here
          }
      }
      class SomeClass {
          class var computedTypeProperty: Int {
              // return an Int value here
          }
      }
</code></p></li>
<li><p>Querying and Setting Type Properties
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  println(SomeClass.computedTypeProperty)
</span><span class='line'>  // prints &ldquo;42&rdquo;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  println(SomeStructure.storedTypeProperty)
</span><span class='line'>  // prints "Some value."
</span><span class='line'>  SomeStructure.storedTypeProperty = "Another value."
</span><span class='line'>  println(SomeStructure.storedTypeProperty)
</span><span class='line'>  // prints "Another value."
</span><span class='line'>
</span><span class='line'>  struct AudioChannel {
</span><span class='line'>  static let thresholdLevel = 10
</span><span class='line'>  static var maxInputLevelForAllChannels = 0
</span><span class='line'>  var currentLevel: Int = 0 {
</span><span class='line'>      didSet {
</span><span class='line'>          if currentLevel &gt; AudioChannel.thresholdLevel {
</span><span class='line'>              // cap the new audio level to the threshold level
</span><span class='line'>              currentLevel = AudioChannel.thresholdLevel
</span><span class='line'>          }
</span><span class='line'>          if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels {
</span><span class='line'>              // store this as the new overall maximum input level
</span><span class='line'>              AudioChannel.maxInputLevelForAllChannels = currentLevel
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  var leftChannel = AudioChannel()
</span><span class='line'>  var rightChannel = AudioChannel()
</span><span class='line'>
</span><span class='line'>  leftChannel.currentLevel = 7
</span><span class='line'>  println(leftChannel.currentLevel)
</span><span class='line'>  // prints "7"
</span><span class='line'>  println(AudioChannel.maxInputLevelForAllChannels)
</span><span class='line'>  // prints "7"
</span><span class='line'>
</span><span class='line'>  rightChannel.currentLevel = 11
</span><span class='line'>  println(rightChannel.currentLevel)
</span><span class='line'>  // prints "10"
</span><span class='line'>  println(AudioChannel.maxInputLevelForAllChannels)
</span><span class='line'>  // prints "10"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;h3&gt;Subscripts&lt;/h3&gt;
</span><span class='line'>
</span><span class='line'>&lt;ul&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Classes, structures, and enumerations can define subscripts, which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an Array instance as someArray[index] and elements in a Dictionary instance as someDictionary[key].&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Subscript Syntax</span></code></pre></td></tr></table></div></figure>
      subscript(index: Int) -> Int {
          get {
              // return an appropriate subscript value here
          }
          set(newValue) {
              // perform a suitable setting action here
          }
      }</p>

<pre><code>  // if you want a subscript to be read-only
  subscript(index: Int) -&gt; Int {
      // return an appropriate subscript value here
  }
</code></pre>

<p>&#8220;`</p></li>
<li>A sample, an array to output multiplied index
<code>
      struct TimesTable {
          let multiplier: Int
          subscript(index: Int) -&gt; Int {
              return multiplier * index
          }
      }
      let threeTimesTable = TimesTable(multiplier: 3)
      println("six times three is \(threeTimesTable[6])")
      // prints "six times three is 18"
</code></li>
<li><p>A sample, a matrix-like structure
&#8220;`
      struct Matrix {
          let rows: Int, columns: Int
          var grid: [Double]
          init(rows: Int, columns: Int) {
              self.rows = rows
              self.columns = columns
              grid = Array(count: rows * columns, repeatedValue: 0.0)
          }
          func indexIsValidForRow(row: Int, column: Int) -> Bool {
              return row >= 0 &amp;&amp; row &lt; rows &amp;&amp; column >= 0 &amp;&amp; column &lt; columns
          }
          subscript(row: Int, column: Int) -> Double {
              get {
                  assert(indexIsValidForRow(row, column: column), &ldquo;Index out of range&rdquo;)
                  return grid[(row * columns) + column]
              }
              set {
                  assert(indexIsValidForRow(row, column: column), &ldquo;Index out of range&rdquo;)
                  grid[(row * columns) + column] = newValue
              }
          }
      }</p>

<pre><code>  // Usage
  var matrix = Matrix(rows: 2, columns: 2)
  matrix[0, 1] = 1.5
  matrix[1, 0] = 3.2
</code></pre>

<p>&#8220;`</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
