<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2014-09-25T19:11:23+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 6 - Functions]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/25/learning-swift-part-6/"/>
    <updated>2014-09-25T18:54:45+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/25/learning-swift-part-6</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<p>Tuple in switch statement is interesting.</p>

<h2>===== Full Notes =====</h2>

<h3>Functions</h3>

<ul>
<li>Defining and Calling Functions
<code>swift
      func sayHello(personName: String) -&gt; String {
          let greeting = "Hello, " + personName + "!"
          return greeting
      }
</code></li>
<li>Function Parameters and Return Values</li>
<li>Multiple Input Parameters
<code>
      func halfOpenRangeLength(start: Int, end: Int) -&gt; Int {
          return end - start
      }
      println(halfOpenRangeLength(1, 10))
      // prints "9"
</code></li>
<li>Functions Without Parameters
<code>
      func sayHelloWorld() -&gt; String {
          return "hello, world"
      }
      println(sayHelloWorld())
      // prints "hello, world"
</code></li>
<li>Function Without Return Values
<code>
      func sayGoodbye(personName: String) {
          println("Goodbye, \(personName)!")
      }
      sayGoodbye("Dave")
      // prints "Goodbye, Dave!"
</code></li>
</ul>


<!-- more -->


<ul>
<li><p>Functions with Multiple Return Values
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  func minMax(array: [Int]) -&gt; (min: Int, max: Int) {
</span><span class='line'>      var currentMin = array[0]
</span><span class='line'>      var currentMax = array[0]
</span><span class='line'>      for value in array[1..&lt;array.count] {
</span><span class='line'>          if value &lt; currentMin {
</span><span class='line'>              currentMin = value
</span><span class='line'>          } else if value &gt; currentMax {
</span><span class='line'>              currentMax = value
</span><span class='line'>          }
</span><span class='line'>      }
</span><span class='line'>      return (currentMin, currentMax)
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  let bounds = minMax([8, -6, 2, 109, 3, 71])
</span><span class='line'>  println("min is \(bounds.min) and max is \(bounds.max)")
</span><span class='line'>  // prints "min is -6 and max is 109"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Optional Tuple Return Types</span></code></pre></td></tr></table></div></figure>
      func minMax(array: [Int]) -> (min: Int, max: Int)? {
          if array.isEmpty { return nil }
          var currentMin = array[0]
          var currentMax = array[0]
          for value in array[1..&lt;array.count] {
              if value &lt; currentMin {
                  currentMin = value
              } else if value > currentMax {
                  currentMax = value
              }
          }
          return (currentMin, currentMax)
      }</p>

<pre><code>  if let bounds = minMax([8, -6, 2, 109, 3, 71]) {
      println("min is \(bounds.min) and max is \(bounds.max)")
  }
  // prints "min is -6 and max is 109"
</code></pre>

<p>&#8220;`</p></li>
<li><p>External parameter Names
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  func someFunction(externalParameterName localParameterName: Int) {
</span><span class='line'>      // function body goes here, and can use localParameterName
</span><span class='line'>      // to refer to the argument value for that parameter
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  func join(string s1: String, toString s2: String, withJoiner joiner: String)
</span><span class='line'>  -&gt; String {
</span><span class='line'>      return s1 + joiner + s2
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  join(string: "hello", toString: "world", withJoiner: ", ")
</span><span class='line'>  // returns "hello, world"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Shorthand External Parameter Names</span></code></pre></td></tr></table></div></figure>
      func containsCharacter(#string: String, #characterToFind: Character) -> Bool {
          for character in string {
              if character == characterToFind {
                  return true
              }
          }
          return false
      }</p>

<pre><code>  let containsAVee = containsCharacter(string: "aardvark", characterToFind: "v")
  // containsAVee equals true, because "aardvark" contains a "v"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Default Parameter Values
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  func join(string s1: String, toString s2: String,
</span><span class='line'>      withJoiner joiner: String = &ldquo; &rdquo;) -&gt; String {
</span><span class='line'>          return s1 + joiner + s2
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  join(string: "hello", toString: "world", withJoiner: "-")
</span><span class='line'>  // returns "hello-world"
</span><span class='line'>
</span><span class='line'>  join(string: "hello", toString: "world")
</span><span class='line'>  // returns "hello world"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;External Names for Parameters with Default Values (automatically generated)</span></code></pre></td></tr></table></div></figure>
      func join(s1: String, s2: String, joiner: String = &ldquo; &rdquo;) -> String {
          return s1 + joiner + s2
      }</p>

<pre><code>  join("hello", "world", joiner: "-")
  // returns "hello-world"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Variadic Parameters (varargs)
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  // Note that Double&hellip; is different from [Double]&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  func arithmeticMean(numbers: Double...) -&gt; Double {
</span><span class='line'>  var total: Double = 0
</span><span class='line'>  for number in numbers {
</span><span class='line'>      total += number
</span><span class='line'>  }
</span><span class='line'>  return total / Double(numbers.count)
</span><span class='line'>  }
</span><span class='line'>  arithmeticMean(1, 2, 3, 4, 5)
</span><span class='line'>  // returns 3.0, which is the arithmetic mean of these five numbers
</span><span class='line'>  arithmeticMean(3, 8.25, 18.75)
</span><span class='line'>  // returns 10.0, which is the arithmetic mean of these three numbers
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Constant and Variable Parameters
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  func alignRight(var string: String, count: Int, pad: Character) -&gt; String {
</span><span class='line'>      let amountToPad = count - countElements(string)
</span><span class='line'>      if amountToPad &lt; 1 {
</span><span class='line'>          return string
</span><span class='line'>      }
</span><span class='line'>      let padString = String(pad)
</span><span class='line'>      for _ in 1...amountToPad {
</span><span class='line'>          string = padString + string
</span><span class='line'>      }
</span><span class='line'>      return string
</span><span class='line'>  }
</span><span class='line'>  let originalString = "hello"
</span><span class='line'>  let paddedString = alignRight(originalString, 10, "-")
</span><span class='line'>  // paddedString is equal to "-----hello"
</span><span class='line'>  // originalString is still equal to "hello"
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;In-Out Parameters</span></code></pre></td></tr></table></div></figure>
      // Variable parameters, as described above, can only be changed within the function itself. If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</p>

<pre><code>  func swapTwoInts(inout a: Int, inout b: Int) {
      let temporaryA = a
      a = b
      b = temporaryA
  }

  var someInt = 3
  var anotherInt = 107
  swapTwoInts(&amp;someInt, &amp;anotherInt)
  println("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
  // prints "someInt is now 107, and anotherInt is now 3"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Function Type
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  func addTwoInts(a: Int, b: Int) -&gt; Int {
</span><span class='line'>      return a + b
</span><span class='line'>  }
</span><span class='line'>  func multiplyTwoInts(a: Int, b: Int) -&gt; Int {
</span><span class='line'>      return a * b
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;  var mathFunction: (Int, Int) -&gt; Int = addTwoInts
</span><span class='line'>
</span><span class='line'>  println("Result: \(mathFunction(2, 3))")
</span><span class='line'>  // prints "Result: 5"
</span><span class='line'>
</span><span class='line'>  mathFunction = multiplyTwoInts
</span><span class='line'>  println("Result: \(mathFunction(2, 3))")
</span><span class='line'>  // prints "Result: 6"
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;```&lt;/p&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;Function Types as Parameter Types
</span><span class='line'>&lt;code&gt;
</span><span class='line'>  func printMathResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int) {
</span><span class='line'>      println("Result: \(mathFunction(a, b))")
</span><span class='line'>  }
</span><span class='line'>  printMathResult(addTwoInts, 3, 5)
</span><span class='line'>  // prints "Result: 8"
</span><span class='line'>&lt;/code&gt;&lt;/li&gt;
</span><span class='line'>&lt;li&gt;&lt;p&gt;Function Type as Return Types</span></code></pre></td></tr></table></div></figure>
      func stepForward(input: Int) -> Int {
          return input + 1
      }
      func stepBackward(input: Int) -> Int {
          return input - 1
      }</p>

<pre><code>  func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
      return backwards ? stepBackward : stepForward
  }

  var currentValue = 3
  let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
  // moveNearerToZero now refers to the stepBackward() function

  println("Counting to zero:")
  // Counting to zero:
  while currentValue != 0 {
      println("\(currentValue)... ")
      currentValue = moveNearerToZero(currentValue)
  }
  println("zero!")
  // 3...
  // 2...
  // 1...
  // zero!
</code></pre>

<p>&#8220;`</p></li>
<li>Nested Functions
<code>
      func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
          func stepForward(input: Int) -&gt; Int { return input + 1 }
          func stepBackward(input: Int) -&gt; Int { return input - 1 }
          return backwards ? stepBackward : stepForward
      }
      var currentValue = -4
      let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)
      // moveNearerToZero now refers to the nested stepForward() function
      while currentValue != 0 {
          println("\(currentValue)... ")
          currentValue = moveNearerToZero(currentValue)
      }
      println("zero!")
      // -4...
      // -3...
      // -2...
      // -1...
      // zero!
</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 5 - Control Flow]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/19/learning-swift-part-5/"/>
    <updated>2014-09-19T15:14:08+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/19/learning-swift-part-5</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<p>Tuple in switch statement is interesting.</p>

<h2>===== Full Notes =====</h2>

<h3>Control Flow</h3>

<ul>
<li>For-In

<ul>
<li><p>Sample</p>

<pre><code>  for index in 1...5 {
      println("\(index) times 5 is \(index * 5)")
  }
  // 1 times 5 is 5
  // 2 times 5 is 10
  // 3 times 5 is 15
  // 4 times 5 is 20
  // 5 times 5 is 25
</code></pre></li>
<li><p>if no need of value from the range</p>

<pre><code>  let base = 3
  let power = 10
  var answer = 1
  for _ in 1...power {
      answer *= base
  }
  println("\(base) to the power of \(power) is \(answer)")
  // prints "3 to the power of 10 is 59049"
</code></pre></li>
<li><p>Use in array</p>

<pre><code>  let names = ["Anna", "Alex", "Brian", "Jack"]
  for name in names {
      println("Hello, \(name)!")
  }
  // Hello, Anna!
  // Hello, Alex!
  // Hello, Brian!
  // Hello, Jack!
</code></pre></li>
<li><p>Use in dictionary</p>

<pre><code>  let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]
  for (animalName, legCount) in numberOfLegs {
      println("\(animalName)s have \(legCount) legs")
  }
  // spiders have 8 legs
  // cats have 4 legs
  // ants have 6 legs
</code></pre></li>
<li><p>Use in string</p>

<pre><code>  for character in "Hello" {
      println(character)
  }
  // H
  // e
  // l
  // l
  // o
</code></pre></li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>For</p>

<ul>
<li><p>Sample</p>

<pre><code>  for var index = 0; index &lt; 3; ++index {
      println("index is \(index)")
  }
  // index is 0
  // index is 1
  // index is 2
</code></pre></li>
<li><p>Index is only accessible in the loop</p>

<pre><code>  var index: Int
  for index = 0; index &lt; 3; ++index {
      println("index is \(index)")
  }
  // index is 0
  // index is 1
  // index is 2
  println("The loop statements were executed \(index) times")
  // prints "The loop statements were executed 3 times"
</code></pre></li>
</ul>
</li>
<li><p>While Loops</p>

<ul>
<li><p>Snakes and Ladders</p>

<pre><code>  let finalSquare = 25
  var board = [Int](count: finalSquare + 1, repeatedValue: 0)

  board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
  board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08

  var square = 0
  var diceRoll = 0
  while square &lt; finalSquare {
      // roll the dice
      if ++diceRoll == 7 { diceRoll = 1 }
      // move by the rolled amount
      square += diceRoll
      if square &lt; board.count {
          // if we're still on the board, move up or down for a snake or a ladder
          square += board[square]
      }
  }
  println("Game over!")
</code></pre></li>
</ul>
</li>
<li><p>Do-While</p>

<ul>
<li><p>Snakes and Ladders</p>

<pre><code>  let finalSquare = 25
  var board = [Int](count: finalSquare + 1, repeatedValue: 0)
  board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
  board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
  var square = 0
  var diceRoll = 0

  do {
      // move up or down for a snake or ladder
      square += board[square]
      // roll the dice
      if ++diceRoll == 7 { diceRoll = 1 }
      // move by the rolled amount
      square += diceRoll
  } while square &lt; finalSquare
  println("Game over!")
</code></pre></li>
</ul>
</li>
<li><p>If</p>

<ul>
<li><p>Sample
      var temperatureInFahrenheit = 30
      if temperatureInFahrenheit &lt;= 32 {
          println(&ldquo;It&rsquo;s very cold. Consider wearing a scarf.&rdquo;)
      }
      // prints &ldquo;It&rsquo;s very cold. Consider wearing a scarf.&rdquo;</p>

<pre><code>  temperatureInFahrenheit = 40
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else {
      println("It's not that cold. Wear a t-shirt.")
  }
  // prints "It's not that cold. Wear a t-shirt."

  temperatureInFahrenheit = 90
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else if temperatureInFahrenheit &gt;= 86 {
      println("It's really warm. Don't forget to wear sunscreen.")
  } else {
      println("It's not that cold. Wear a t-shirt.")
  }
  // prints "It's really warm. Don't forget to wear sunscreen."

  temperatureInFahrenheit = 72
  if temperatureInFahrenheit &lt;= 32 {
      println("It's very cold. Consider wearing a scarf.")
  } else if temperatureInFahrenheit &gt;= 86 {
      println("It's really warm. Don't forget to wear sunscreen.")
  }
</code></pre></li>
</ul>
</li>
<li><p>Switch</p>

<ul>
<li><p>Sample</p>

<pre><code>  switch some value to consider {
  case value 1:
      respond to value 1
  case value 2,
  value 3:
      respond to value 2 or 3
  default:
      otherwise, do something else
  }
</code></pre></li>
<li><p>Use with char</p>

<pre><code>  let someCharacter: Character = "e"
  switch someCharacter {
  case "a", "e", "i", "o", "u":
      println("\(someCharacter) is a vowel")
  case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
  "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
      println("\(someCharacter) is a consonant")
  default:
      println("\(someCharacter) is not a vowel or a consonant")
  }
  // prints "e is a vowel"
</code></pre></li>
<li><p>No Implicit Fallthrough</p>

<p>  In contrast with switch statements in C and Objective-C, switch statements in Swift do not fall through the bottom of each case and into the next one by default. Instead, the entire switch statement finishes its execution as soon as the first matching switch case is completed, without requiring an explicit break statement. This makes the switch statement safer and easier to use than in C, and avoids executing more than one switch case by mistake.</p></li>
<li><p>Bad case</p>

<pre><code>  let anotherCharacter: Character = "a"
  switch anotherCharacter {
  case "a":                       // Each case must contain at least one executable statement.
  case "A":
      println("The letter A")
  default:
      println("Not the letter A")
  }
  // this will report a compile-time error
</code></pre></li>
<li><p>Range Matching</p>

<pre><code>  let count = 3_000_000_000_000
  let countedThings = "stars in the Milky Way"
  var naturalCount: String
  switch count {
  case 0:
      naturalCount = "no"
  case 1...3:
      naturalCount = "a few"
  case 4...9:
      naturalCount = "several"
  case 10...99:
      naturalCount = "tens of"
  case 100...999:
      naturalCount = "hundreds of"
  case 1000...999_999:
      naturalCount = "thousands of"
  default:
      naturalCount = "millions and millions of"
  }
</code></pre></li>
<li><p>Tuple</p>

<pre><code>  let somePoint = (1, 1)
  switch somePoint {
  case (0, 0):
      println("(0, 0) is at the origin")
  case (_, 0):
      println("(\(somePoint.0), 0) is on the x-axis")
  case (0, _):
      println("(0, \(somePoint.1)) is on the y-axis")
  case (-2...2, -2...2):
      println("(\(somePoint.0), \(somePoint.1)) is inside the box")
  default:
      println("(\(somePoint.0), \(somePoint.1)) is outside of the box")
  }
  // prints "(1, 1) is inside the box"
</code></pre></li>
<li><p>Value Bindings</p>

<pre><code>  let anotherPoint = (2, 0)
  switch anotherPoint {
  case (let x, 0):
      println("on the x-axis with an x value of \(x)")
  case (0, let y):
      println("on the y-axis with a y value of \(y)")
  case let (x, y):
      println("somewhere else at (\(x), \(y))")
  }
  // prints "on the x-axis with an x value of 2"
</code></pre></li>
<li><p>Where</p>

<pre><code>  let yetAnotherPoint = (1, -1)
  switch yetAnotherPoint {
  case let (x, y) where x == y:
      println("(\(x), \(y)) is on the line x == y")
  case let (x, y) where x == -y:
      println("(\(x), \(y)) is on the line x == -y")
  case let (x, y):
      println("(\(x), \(y)) is just some arbitrary point")
  }
  // prints "(1, -1) is on the line x == -y"
</code></pre></li>
</ul>
</li>
<li><p>Control Transfer Statements</p>

<ul>
<li><p>Continue<br/>
The continue statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop. It says “I am done with the current loop iteration” without leaving the loop altogether.</p>

<pre><code>    let puzzleInput = "great minds think alike"
    var puzzleOutput = ""
    for character in puzzleInput {
        switch character {
        case "a", "e", "i", "o", "u", " ":
            continue
        default:
            puzzleOutput.append(character)
        }
    }
    println(puzzleOutput)
    // prints "grtmndsthnklk"
</code></pre>

<ul>
<li><p>Break</p>

<pre><code>  let numberSymbol: Character = "三"  // Simplified Chinese for the number 3
  var possibleIntegerValue: Int?
  switch numberSymbol {
  case "1", "١", "一", "๑":
      possibleIntegerValue = 1
  case "2", "٢", "二", "๒":
      possibleIntegerValue = 2
  case "3", "٣", "三", "๓":
      possibleIntegerValue = 3
  case "4", "٤", "四", "๔":
      possibleIntegerValue = 4
  default:
      break
  }
  if let integerValue = possibleIntegerValue {
      println("The integer value of \(numberSymbol) is \(integerValue).")
  } else {
      println("An integer value could not be found for \(numberSymbol).")
  }
  // prints "The integer value of 三 is 3."
</code></pre></li>
<li><p>Explicit Fallthrough<br/>
The fallthrough keyword does not check the case conditions for the switch case that it causes execution to fall into. The fallthrough keyword simply causes code execution to move directly to the statements inside the next case (or default case) block, as in C’s standard switch statement behavior.</p>

<pre><code>  let integerToDescribe = 5
  var description = "The number \(integerToDescribe) is"
  switch integerToDescribe {
  case 2, 3, 5, 7, 11, 13, 17, 19:
      description += " a prime number, and also"
      fallthrough
  default:
      description += " an integer."
  }
  println(description)
  // prints "The number 5 is a prime number, and also an integer."
</code></pre></li>
<li><p>Labeled Statements</p>

<pre><code>  gameLoop: while square != finalSquare {
      if ++diceRoll == 7 { diceRoll = 1 }
      switch square + diceRoll {
      case finalSquare:
          // diceRoll will move us to the final square, so the game is over
          break gameLoop
      case let newSquare where newSquare &gt; finalSquare:
          // diceRoll will move us beyond the final square, so roll again
          continue gameLoop
      default:
          // this is a valid move, so find out its effect
          square += diceRoll
          square += board[square]
      }
  }
  println("Game over!")
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 4 - Strings and Characters]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/08/learning-swift-part-4/"/>
    <updated>2014-09-08T18:03:31+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/08/learning-swift-part-4</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Strings and Characters</h3>

<ul>
<li><p>String Literals</p>

<pre><code>  let someString = "..."
</code></pre></li>
<li><p>Initializing an Empty String</p>

<pre><code>  var emptyString = ""               // empty string literal
  var anotherEmptyString = String()  // initializer syntax
  // these two strings are both empty, and are equivalent to each other

  if emptyString.isEmpty {
      println("Nothing to see here")
  }
</code></pre></li>
<li><p>String Mutability</p>

<pre><code>  var variableString = "Horse"
  variableString += " and carriage"
  // variableString is now "Horse and carriage"

  let constantString = "Highlander"
  constantString += " and another Highlander"
  // this reports a compile-time error - a constant string cannot be modified
</code></pre></li>
<li><p>Strings Are Value Types</p>

<ul>
<li>Swift’s String type is a value type. If you create a new String value, that String value is copied when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing String value is created, and the new copy is passed or assigned, not the original version.</li>
<li>NSString in obj-c is NOT value type.</li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><p>Working with Characters</p>

<pre><code>  for character in "Dog!🐶" {
      println(character)
  }

  // a single character
  let yenSign: Character = "¥"
</code></pre></li>
<li><p>Concatenating Strings and Characters</p>

<pre><code>  let string1 = "hello"
  let string2 = " there"
  var welcome = string1 + string2
  // welcome now equals "hello there"

  var instruction = "look over"
  instruction += string2
  // instruction now equals "look over there"

  let exclamationMark: Character = "!"
  welcome.append(exclamationMark)
  // welcome now equals "hello there!"
</code></pre></li>
<li><p>String Interpolation</p>

<pre><code>  let multiplier = 3
  let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"
  // message is "3 times 2.5 is 7.5"
</code></pre></li>
<li><p>Unicode Scalars</p></li>
<li><p>Special Unicode Characters in String Literals</p>

<pre><code>  let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
  // "Imagination is more important than knowledge" - Einstein
  let dollarSign = "\u{24}"        // $,  Unicode scalar U+0024
  let blackHeart = "\u{2665}"      // ♥,  Unicode scalar U+2665
  let sparklingHeart = "\u{1F496}" // 💖, Unicode scalar U+1F496
</code></pre></li>
<li><p>Extended Grapheme Clusters</p>

<pre><code>  let eAcute: Character = "\u{E9}"                         // é
  let combinedEAcute: Character = "\u{65}\u{301}"          // e followed by ́
  // eAcute is é, combinedEAcute is é

  let precomposed: Character = "\u{D55C}"                  // 한
  let decomposed: Character = "\u{1112}\u{1161}\u{11AB}"   // ᄒ, ᅡ, ᆫ
  // precomposed is 한, decomposed is 한

  let enclosedEAcute: Character = "\u{E9}\u{20DD}"
  // enclosedEAcute is é⃝
</code></pre></li>
<li><p>Counting Characters</p>

<pre><code>  let unusualMenagerie = "Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"
  println("unusualMenagerie has \(countElements(unusualMenagerie)) characters")
  // prints "unusualMenagerie has 40 characters"

  var word = "cafe"
  println("the number of characters in \(word) is \(countElements(word))
  // prints "the number of characters in cafe is 4"

  word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301

  println("the number of characters in \(word) is \(countElements(word))
  // prints "the number of characters in café is 4"
</code></pre></li>
<li><p>Comparing Strings</p>

<ul>
<li><p>String and Character Equality</p>

<pre><code>  let quotation = "We're a lot alike, you and I."
  let sameQuotation = "We're a lot alike, you and I."
  if quotation == sameQuotation {
      println("These two strings are considered equal")
  }
  // prints "These two strings are considered equal"
</code></pre></li>
<li><p>Two String values (or two Character values) are considered equal if their extended grapheme clusters are canonically equivalent.</p>

<pre><code>  // "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE
  let eAcuteQuestion = "Voulez-vous un caf\u{E9}?"

  // "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT
  let combinedEAcuteQuestion = "Voulez-vous un caf\u{65}\u{301}?"

  if eAcuteQuestion == combinedEAcuteQuestion {
      println("These two strings are considered equal")
  }
  // prints "These two strings are considered equal"
</code></pre></li>
<li><p>Conversely, LATIN CAPITAL LETTER A (U+0041, or &ldquo;A&rdquo;), as used in English, is not equivalent to CYRILLIC CAPITAL LETTER A (U+0410, or &ldquo;А&rdquo;).</p>

<pre><code>  let latinCapitalLetterA: Character = "\u{41}"

  let cyrillicCapitalLetterA: Character = "\u{0410}"

  if latinCapitalLetterA != cyrillicCapitalLetterA {
      println("These two characters are not equivalent")
  }
  // prints "These two characters are not equivalent"
</code></pre></li>
<li><p>Prefix and Suffix Equality</p>

<pre><code>  let romeoAndJuliet = [
      "Act 1 Scene 1: Verona, A public place",
      "Act 1 Scene 2: Capulet's mansion",
      "Act 1 Scene 3: A room in Capulet's mansion",
      "Act 1 Scene 4: A street outside Capulet's mansion",
      "Act 1 Scene 5: The Great Hall in Capulet's mansion",
      "Act 2 Scene 1: Outside Capulet's mansion",
      "Act 2 Scene 2: Capulet's orchard",
      "Act 2 Scene 3: Outside Friar Lawrence's cell",
      "Act 2 Scene 4: A street in Verona",
      "Act 2 Scene 5: Capulet's mansion",
      "Act 2 Scene 6: Friar Lawrence's cell"
  ]

  var act1SceneCount = 0
  for scene in romeoAndJuliet {
      if scene.hasPrefix("Act 1 ") {
          ++act1SceneCount
      }
  }
  println("There are \(act1SceneCount) scenes in Act 1")
  // prints "There are 5 scenes in Act 1"

  var mansionCount = 0
  var cellCount = 0
  for scene in romeoAndJuliet {
      if scene.hasSuffix("Capulet's mansion") {
          ++mansionCount
      } else if scene.hasSuffix("Friar Lawrence's cell") {
          ++cellCount
      }
  }
  println("\(mansionCount) mansion scenes; \(cellCount) cell scenes")
  // prints "6 mansion scenes; 2 cell scenes"
</code></pre></li>
<li><p>A collection of UTF-8 code units (accessed with the string’s utf8 property)</p></li>
<li>A collection of UTF-16 code units (accessed with the string’s utf16 property)</li>
<li>A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s unicodeScalars property)</li>
</ul>
</li>
<li><p>UTF-8 Representation</p>

<pre><code>  let dogString = "Dog‼🐶"

  for codeUnit in dogString.utf8 {
      print("\(codeUnit) ")
  }
  print("\n")
  // 68 111 103 226 128 188 240 159 144 182
</code></pre></li>
<li><p>UTF-16 Representation</p>

<pre><code>  for codeUnit in dogString.utf16 {
      print("\(codeUnit) ")
  }
  print("\n")
  // 68 111 103 8252 55357 56374
</code></pre></li>
<li><p>Unicode Scalar Representation</p>

<pre><code>  for scalar in dogString.unicodeScalars {
      print("\(scalar.value) ")
  }
  print("\n")
  // 68 111 103 8252 128054

  for scalar in dogString.unicodeScalars {
      println("\(scalar) ")
  }
  // D
  // o
  // g
  // ‼
  // 🐶
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 3 - Basic Operators]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-3/"/>
    <updated>2014-09-05T17:59:28+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-3</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Basic Operators</h3>

<ul>
<li><p>Terminology</p>

<pre><code>  - Unary
  - Binary
  - Ternary (There is only one in a ? b :c)
</code></pre></li>
<li><p>Assignment Operator</p>

<pre><code>  // Not a vaild assignment
  if x = y {

  }
</code></pre></li>
<li><p>Arithmetic Operators</p>

<ul>
<li>Not allow overflow.</li>
<li>You can opt in to value overflow behavior by using Swift&rsquo;s overflow operators (such as a &amp;+ b).</li>
<li><p>The addition operator is also supported for <strong>String</strong> concatenation.</p>

<p>  let dog: Character = &ldquo;🐶&rdquo;
  let cow: Character = &ldquo;🐮&rdquo;
  let dogCow = dog + cow
  // dogCow is equal to &ldquo;🐶🐮&rdquo;</p></li>
</ul>
</li>
<li><p>Remainder Operator</p>

<ul>
<li><code>9 % 4 // equals 1</code></li>
<li><code>-9 % 4 // equals -1</code></li>
<li><code>-9 % 4 // equals -9 % -4</code></li>
</ul>
</li>
</ul>


<!-- more -->


<p></p>

<ul>
<li><p>Floating-Point Remainder Calculations</p>

<ul>
<li><code>8 % 2.5 // equals 0.5</code></li>
</ul>
</li>
<li><p>Increment and Decrement Operators</p>

<ul>
<li><code>++</code> and <code>--</code> works the same as C</li>
</ul>
</li>
<li><p>Unary Minus Operator and Unary Plus Operator</p>

<ul>
<li><code>+</code> do <strong>NOT</strong> change the value</li>
</ul>
</li>
<li><p>Compound Assignment Operators</p>

<pre><code>  var a = 1
  a += 2
</code></pre></li>
<li><p>Comparison Operators</p>

<pre><code>  Equal to (a == b)
  Not equal to (a != b)
  Greater than (a &gt; b)
  Less than (a &lt; b)
  Greater than or equal to (a &gt;= b)
  Less than or equal to (a &lt;= b)
</code></pre></li>
<li><p>Nil Coalescing Operator</p>

<ul>
<li><p>The nil coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil.</p>

<p>  let defaultColorName = &ldquo;red&rdquo;
  var userDefinedColorName: String?   // defaults to nil</p>

<p>  var colorNameToUse = userDefinedColorName ?? defaultColorName
  // userDefinedColorName is nil, so colorNameToUse is set to the default of &ldquo;red&rdquo;</p></li>
</ul>
</li>
<li><p>Range Operators</p>

<pre><code>  for index in 1...5 {
      println("\(index) times 5 is \(index * 5)")
  }
  // 1 times 5 is 5
  // 2 times 5 is 10
  // 3 times 5 is 15
  // 4 times 5 is 20
  // 5 times 5 is 25
</code></pre></li>
<li><p>Half-Open Range Operator</p>

<pre><code>  let names = ["Anna", "Alex", "Brian", "Jack"]
  let count = names.count
  for i in 0..&lt;count {
      println("Person \(i + 1) is called \(names[i])")
  }
  // Person 1 is called Anna
  // Person 2 is called Alex
  // Person 3 is called Brian
  // Person 4 is called Jack&gt;
</code></pre></li>
<li><p>Logical Operators</p>

<ul>
<li>Logical NOT (!a)</li>
<li>Logical AND (a &amp;&amp; b)</li>
<li>Logical OR (a || b)</li>
<li>Logical NOT (!a)</li>
</ul>
</li>
<li><p>Combining Logical Operators</p>

<pre><code>  if enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword {
      println("Welcome!")
  } else {
      println("ACCESS DENIED")
  }
  // prints "Welcome!"
</code></pre></li>
<li><p>Explicit Parentheses</p>

<pre><code>  if (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword {
      println("Welcome!")
  } else {
      println("ACCESS DENIED")
  }
  // prints "Welcome!"
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 2 - Basics]]></title>
    <link href="http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-2/"/>
    <updated>2014-09-05T15:06:10+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/09/05/learning-swift-part-2</id>
    <content type="html"><![CDATA[<p>Just some notes after reading Apple&rsquo;s official online guide.
Most code are from the guide, with some modification by me.</p>

<h2>===== Full Notes =====</h2>

<h3>Basics</h3>

<ul>
<li><p>Declaring Constant and Variables
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'>  <span class="k">let</span> <span class="n">maximumNumberOfLoginAttempts</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">currentLoginAttempt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">Type</span> <span class="n">Annotations</span>
</span></code></pre></td></tr></table></div></figure>
      var welcomeMessgae: String
      welcomeMessgae = &ldquo;Hello&rdquo;</p>

<pre><code>  var red, green, blue: Double // Multiple variables defined
</code></pre>

<p>&#8220;`</p></li>
<li>Naming Constants and Variables
<code>
      let π = 3.14159
      let 你好 = "你好世界"
      let 🐶🐮 = "dogcow"
</code></li>
</ul>


<!-- more -->


<h3>Integers</h3>

<ul>
<li>Integer Bounds
<code>
      let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
      let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8
</code></li>
<li><p>Int</p>

<ul>
<li><p>On a 32-bit platform, Int is the same size as Int32.</p></li>
<li><p>On a 64-bit platform, Int is the same size as Int64.</p></li>
</ul>
</li>
<li><p>UInt</p>

<ul>
<li><p>On a 32-bit platform, UInt is the same size as UInt32.</p></li>
<li><p>On a 64-bit platform, UInt is the same size as UInt64.</p></li>
</ul>
</li>
<li><p>Floating-Point Numbers</p>

<ul>
<li>Double has a precision of at least 15 decimal digits, whereas the precision of Float can be as little as 6 decimal digits. T</li>
</ul>
</li>
<li><p>Type Safety and Type Inference</p></li>
<li><p>Numeric Literals
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'>  <span class="k">let</span> <span class="n">decimalInteger</span> <span class="o">=</span> <span class="mi">17</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">binaryInteger</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b10001</span>       <span class="c1">// 17 in binary notation</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">octalInteger</span> <span class="o">=</span> <span class="mi">0</span><span class="n">o21</span>           <span class="c1">// 17 in octal notation</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">hexadecimalInteger</span> <span class="o">=</span> <span class="mh">0x11</span>     <span class="c1">// 17 in hexadecimal notation&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="mf">1.25e2</span>          <span class="c1">// 125.0</span>
</span><span class='line'>  <span class="mf">1.25e-2</span>         <span class="c1">// 0.0125</span>
</span><span class='line'>  <span class="mh">0xF</span><span class="n">p2</span>           <span class="c1">// 60.0 = 15 x 2 x 2</span>
</span><span class='line'>  <span class="mh">0xF</span><span class="n">p</span><span class="o">-</span><span class="mi">2</span>          <span class="c1">// 3.75 = 15 x 0.5 x 0.5</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Can have additional formatting literal (like Ruby)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">let</span> <span class="n">paddedDouble</span> <span class="o">=</span> <span class="mf">000123.456</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">oneMillion</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">justOverOneMillion</span> <span class="o">=</span> <span class="mi">1</span><span class="n">_000_000</span><span class="mf">.000</span><span class="n">_000_1</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Integer</span> <span class="n">Conversion</span>
</span></code></pre></td></tr></table></div></figure>
      let cannotBeNegative: UInt8 = -1
      // UInt8 cannot store negative numbers, and so this will report an error
      let tooBig: Int8 = Int8.max + 1
      // Int8 cannot store a number larger than its maximum value,
      // and so this will also report an error</p>

<pre><code>  // conversion must be explicit

  let twoThousand: UInt16 = 2_000
  let one: UInt8 = 1
  let twoThousandAndOne = twoThousand + UInt16(one)
</code></pre>

<p>&#8220;`</p></li>
<li><p>Integer and Floating-Point Conversion
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'>  <span class="k">let</span> <span class="n">three</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">pointOneFourOneFiveNine</span> <span class="o">=</span> <span class="mf">0.14159</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">Double</span><span class="p">(</span><span class="n">three</span><span class="p">)</span> <span class="o">+</span> <span class="n">pointOneFourOneFiveNine</span>
</span><span class='line'>  <span class="c1">// pi equals 3.14159, and is inferred to be of type Double&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">let</span> <span class="n">integerPi</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">// integerPi equals 3, and is inferred to be of type Int</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="kt">Type</span> <span class="n">Aliases</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">typealias</span> <span class="n">AudioSample</span> <span class="o">=</span> <span class="kt">UInt16</span>
</span><span class='line'>  <span class="k">var</span> <span class="n">maxAmplitudeFound</span> <span class="o">=</span> <span class="n">AudioSample</span><span class="p">.</span><span class="n">min</span>
</span><span class='line'>  <span class="c1">// maxAmplitudeFound is now 0</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">Boolean</span>
</span></code></pre></td></tr></table></div></figure>
      let orangesAreOrange = true
      let turnipsAreDelicious = false</p>

<pre><code>  if turnipsAreDelicious {
      println("Mmm, tasty turnips!")
  } else {
      println("Eww, turnips are horrible.")
  }
  // prints "Eww, turnips are horrible."
</code></pre>

<p>&#8220;`</p></li>
</ul>


<h3>Tuples</h3>

<ul>
<li>Sample
<code>
      let http404Error = (404, "Not Found")
      // http404Error is of type (Int, String), and equals (404, "Not Found")
</code></li>
<li>Decompose a tuple
<code>
      let (statusCode, statusMessage) = http404Error
      println("The status code is \(statusCode)")
      // prints "The status code is 404"
      println("The status message is \(statusMessage)")
      // prints "The status message is Not Found"
</code></li>
<li>Ignore some value when decomposing
<code>
      let (justTheStatusCode, _) = http404Error
      println("The status code is \(justTheStatusCode)")
      // prints "The status code is 404"
</code></li>
<li>Access by index
<code>
      println("The status code is \(http404Error.0)")
      // prints "The status code is 404"
      println("The status message is \(http404Error.1)")
      // prints "The status message is Not Found"
</code>

<h3>Optionals</h3></li>
<li>Sample
<code>
      let possibleNumber = "123"
      let convertedNumber = possibleNumber.toInt()
      // convertedNumber is inferred to be of type "Int?", or "optional Int"
</code></li>
<li><p>nil
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'>  <span class="k">var</span> <span class="nl">serverResponseCode</span><span class="p">:</span> <span class="n">Int</span><span class="o">?</span> <span class="o">=</span> <span class="mi">404</span>
</span><span class='line'>  <span class="c1">// serverResponseCode contains an actual Int value of 404</span>
</span><span class='line'>  <span class="n">serverResponseCode</span> <span class="o">=</span> <span class="nb">nil</span>
</span><span class='line'>  <span class="c1">// serverResponseCode now contains no value&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>  <span class="k">var</span> <span class="nl">surveyAnswer</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span>
</span><span class='line'>  <span class="c1">// surveyAnswer is automatically set to nil</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="n">If</span> <span class="n">Statements</span> <span class="n">and</span> <span class="n">Forced</span> <span class="n">Unwrapping</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">convertedNumber</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">println</span><span class="p">(</span><span class="s">&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// prints &quot;convertedNumber has an integer value of 123.&quot;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Optional</span> <span class="n">Binding</span>
</span></code></pre></td></tr></table></div></figure>
      if let constantName = someOptional {
          statements
      }</p>

<pre><code>  if let actualNumber = possibleNumber.toInt() {
      println("\(possibleNumber) has an integer value of \(actualNumber)")
  } else {
      println("\(possibleNumber) could not be converted to an integer")
  }
  // prints "123 has an integer value of 123"
</code></pre>

<p>&#8220;`</p></li>
<li><p>Implicitly Unwrapping Optionals (Accessing an implicitly unwrapped optional when it does not contain a value will trigger a RTE)
&#8220;`
      let possibleString: String? = &ldquo;An optional string.&rdquo;
      let forcedString: String = possibleString! // requires an exclamation mark</p>

<pre><code>  let assumedString: String! = "An implicitly unwrapped optional string."
  let implicitString: String = assumedString // no need for an exclamation mark

  if assumedString != nil {
      println(assumedString)
  }
  // prints "An implicitly unwrapped optional string."

  if let definiteString = assumedString {
      println(definiteString)
  }
  // prints "An implicitly unwrapped optional string."
</code></pre>

<p>&#8220;`</p></li>
<li><p>Assertions</p></li>
<li><p>Debugging with Assertions
<code>
      let age = -3
      assert(age &gt;= 0, "A person's age cannot be less than zero")
      // this causes the assertion to trigger, because age is not &gt;= 0
</code></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
