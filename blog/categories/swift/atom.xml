<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-10-28T18:35:30+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning RxSwift's Github Sample]]></title>
    <link href="http://zh-wang.github.io/blog/2015/10/27/learning-rxswifts-github-sample/"/>
    <updated>2015-10-27T16:05:38+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/10/27/learning-rxswifts-github-sample</id>
    <content type="html"><![CDATA[<p>Examples of RxSwift can be found here. <a href="https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples">https://github.com/ReactiveX/RxSwift/tree/master/RxExample/RxExample/Examples</a></p>

<p>The first example is mock Github sign-up view controller. It checks availability of user name, password. Then simulate a sign-up process.</p>

<p> In a common sign-up process, we have to check</p>

<ol>
<li>User name is empty or includes illegal character</li>
<li>User name has been signed up</li>
<li>Password and Password Repeat are the same</li>
<li>Request can be handled correctly or not</li>
</ol>


<p> ### Listen user input
 This is very simple for Rx framework. The <code>rx_text</code> field of <code>UITextField</code> is defined in <code>RxCocoa</code> is just what you want.</p>

<pre><code class="swift">    let username = usernameOutlet.rx_text
</code></pre>

<p>It tracks <code>textViewDidChange</code> wrap all changes into <code>Observable</code>, which is an basic event sequence can be <strong>Observed</strong> by <code>Observer</code>.</p>

<pre><code>let each user input event as E, then this event sequence can be illustrated as
    ---E---E-E-----E-----
</code></pre>

<!-- more -->


<h3>Check availability</h3>

<p>This is a <code>flatmap</code> function for <code>Observable</code>. (Definition on <code>flatmap</code> can be found in this post. <a href="http://zh-wang.github.io/blog/2015/10/09/functor-monad-applicative-in-swift/">Functor, Monad, Applicative in Swift</a></p>

<pre><code class="swift">    typealias ValidationResult = (valid: Bool?, message: String?)

    func validateUsername(username: String) -&gt; Observable&lt;ValidationResult&gt; {
        if username.characters.count == 0 {
            return just((false, nil))
        }

        // this obviously won't be
        if username.rangeOfCharacterFromSet(NSCharacterSet.alphanumericCharacterSet().invertedSet) != nil {
            return just((false, "Username can only contain numbers or digits"))
        }

        let loadingValue = (valid: nil as Bool?, message: "Checking availabilty ..." as String?)

        return API.usernameAvailable(username)
            .map { available in
                if available {
                    return (true, "Username available")
                }
                else {
                    return (false, "Username already taken")
                }
            }
            .startWith(loadingValue)
    }
</code></pre>

<p>The wrapped value in <code>Observable</code> is a <code>Bool</code> and <code>String</code> pair.</p>

<p>The first two <code>if</code> clause are for checking empty and illegal characters, respectively. The result will be returned immediately because they are local process.</p>

<p>The last part is a http request which returns result after a short period of time.</p>

<p>If we call &lsquo;validateUsername&rsquo; at each event in user input event sequence,</p>

<pre><code class="swift">    let usernameValidation = username
    .map { username in
        return validationService.validateUsername(username)
    }
</code></pre>

<p>Event sequence will become (V for validation, R for result)
<code>
    ---+---+-+-----+-----
       |   | |     |
       V   V V     V
       |   | |     |
       R   | |     |
           R |     R
             R
</code>
Note that even validations are called in order, results are returned in random order according to network state. And actually we only need the latest validation&rsquo;s result.</p>

<p>So we use <code>switch</code> method here. <code>switchlatest</code> is one of <code>switch</code>&rsquo;s implementation, which will always switch to the latest event occurred and dispose former events. <a href="http://www.introtorx.com/content/v1.0.10621.0/12_CombiningSequences.html#Switch">Intro_to_rx_switch</a>.</p>

<p>And <code>shareReplay(1)</code> will keep only 1 allocation even this observer gets new subscriptions later. <a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#sharing-subscription-and-sharereplay-operator">Rxswift_replay</a></p>

<pre><code class="swift">    let usernameValidation = username
    .map { username in
        return validationService.validateUsername(username)
    }
    .switchLatest()
    .shareReplay(1)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functor, Monad, Applicative in Swift]]></title>
    <link href="http://zh-wang.github.io/blog/2015/10/09/functor-monad-applicative-in-swift/"/>
    <updated>2015-10-09T10:29:12+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/10/09/functor-monad-applicative-in-swift</id>
    <content type="html"><![CDATA[<p>Some Implementation in Swift.</p>

<h3>Functor</h3>

<p>Let $C$ be a constructor which takes a variable as parameter.</p>

<p>$C$ is a <strong>Functor</strong> if $C$ has the following ability.</p>

<p><script type="math/tex; mode=display">
    C[A].map(A \rightarrow B) = C[B]
</script></p>

<p>For example, we can write such a function <code>map</code> for <code>Optional</code>. (Well, swift already has such built-in function.)
&#8220;`swift
    extension Optional {
        func map<U>(f: Wrapped -> U) -> U? {
            switch self {
                case .Some(let x): return f(x)
                case .None: return .None
            }
        }</p>

<pre><code>    // take out the wrapped item
    func toValue() -&gt; Wrapped? {
        switch self {
            case .Some(let x): return x
            case .None: return .None
        }
    }
}

// A -&gt; B
func plusTwo(addend: Int) -&gt; Double {
    return Double(addend) + 2.0
}

// C[A] -&gt; C[B]
Int?.Some(3).map(plusTwo) // Change Optional&lt;Int&gt;(3) into Optional&lt;Double&gt;(5.0)
</code></pre>

<pre><code>
And we can chain functors like this.
</code></pre>

<pre><code>func plusThree(addend: Int) -&gt; Int {
    return addend + 3
}

Int?.Some(3).map(plusThree).map(plusTwo)
</code></pre>

<pre><code>We can also do it like Haskell
</code></pre>

<pre><code>// This is a custom operator
infix operator &lt;^&gt; { associativity left }
func &lt;^&gt;&lt;T, U&gt;(a: T?, f: T -&gt; U) -&gt; U? {
    return a.map(f)
}

Optional.Some(2) &lt;^&gt; plusThree // Int?(5)
Optional.Some(2) &lt;^&gt; plusThree &lt;^&gt; plusThree // Int?(8)
</code></pre>

<pre><code>
### Monad

$C$ is a __Monad__ if $C$ has the following ability.

<script type="math/tex; mode=display">
    C[A].flatmap(A \rightarrow C[B]) = C[B]
</script>
</code></pre>

<pre><code>extension Optional {
    func flatMap&lt;U&gt;(f: Wrapped -&gt; U?) -&gt; U? {
        switch self {
            case .Some(let x): return f(x)
            case .None: return .None
        }
    }
}

func half(a: Int) -&gt; Int? {
    return a % 2 == 0 ? a / 2 : .None
}

Int?.Some(4).flatMap(half) // Int?(2)
</code></pre>

<pre><code>Haskell-like version.
</code></pre>

<pre><code>infix operator &gt;&gt;- { associativity left }

func &gt;&gt;-&lt;T, U&gt;(a: T?, f: T -&gt; U?) -&gt; U? {
    return a.flatMap(f)
}

Int?(3) &gt;&gt;- half // Optional.None
Int?(4) &gt;&gt;- half &gt;&gt;- half // Int?(2)
</code></pre>

<pre><code>### Applicative

$C$ is a __Applicative__ if $C$ has the following ability.

<script type="math/tex; mode=display">
    C[A].apply(C[A \rightarrow B]) = C[B]
</script>
</code></pre>

<pre><code>extension Optional {
    // Note that function `f` is ALSO wrapped in Optional type
    func apply&lt;U&gt;(f: (Wrapped -&gt; U)?) -&gt; U? {
        switch f {
        case .Some(let someF): return self.map(someF)
        case .None: return .None
        }
    }
}

extension Array {
    // Note that function `f` is ALSO wrapped in Array type
    func apply&lt;U&gt;(fs: [Element -&gt; U]) -&gt; [U] {
        var result = [U]()
        for f in fs {
            for element in self.map(f) {
                result.append(element)
            }
        }
        return result
    }
}

// This is a IntFunction? type
let plusThreeBox = Optional&lt;IntFunction&gt;.Some(plusThree)

Int?.Some(3).apply(plusThreeBox) // Int?(6)

[1, 2, 3].apply( [ {$0 + 10}, {$0 + 100} ] ) // [11, 12, 13, 101, 102, 103]
</code></pre>

<pre><code>Haskell-like version.
</code></pre>

<pre><code>infix operator &lt;*&gt; { associativity left }

func &lt;*&gt;&lt;T, U&gt;(a: T?, f: (T -&gt; U)?) -&gt; U? {
    return a.apply(f)
}

func &lt;*&gt;&lt;T, U&gt;(a: [T], f: [T -&gt; U]) -&gt; [U] {
    return a.apply(f)
}

(Optional.Some(2) &lt;*&gt; Optional.Some({ $0 + 3 }))
// =&gt; 5

[1, 2, 3] &lt;*&gt; [ { $0 + 3 }, { $0 * 2 } ]
// =&gt; [ 4, 5, 6, 2, 4, 6 ]
</code></pre>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift String Operations]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/swift-string-operation/"/>
    <updated>2015-07-02T16:24:46+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/swift-string-operation</id>
    <content type="html"><![CDATA[<p>String operations of Swift seems to be easy to handle, but we should take care of them in development.</p>

<p>For example, this is a common code snippet which stays on the top spot, by searching &lsquo;<strong>swift substring</strong>&rsquo; from <a href="www.google.co.jp">www.google.co.jp</a>.</p>

<pre><code class="swift">extension String {
    public func substring(location:Int, length:Int) -&gt; String! {
        return (self as NSString).substringWithRange(NSMakeRange(location, length))
    }
}
</code></pre>

<p>But, it is not correct. <code>NSString</code>&rsquo;s implementation is based on UTF-16 and handing index for it is just confusing.</p>

<p>Take a look at the following test.</p>

<p><img src="/images/2015_07_02_image01.png" title="Test Failed" alt="IMGAE_A" /></p>

<p>Because index in <code>NSString</code> format is different from index in <code>String</code> format. The text is counted as length 2 in <code>NSString</code>, but only 1 in <code>String</code>.</p>

<p>So using <code>substring</code> in <code>NSString</code> only get half of it, from its binary expression. Then certainly, it cannot be decoded correctly.</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Online Guide</a> has a detail explanation for this problem.</p>

<p>We should use <code>String.Index</code> to handle different byte length of each character, and also decomposed and precomposed characters.</p>

<p>Because <code>String</code> in Swift is implemented as <strong>Unicode Scalar</strong>, or <strong>UTF-32</strong>, is always 4-byte long for each character and it default behaviour can handle composed characters.</p>

<pre><code>    public func substring2(location: Int, length:Int) -&gt; String! {
        assert(location &gt;= 0, "OMG")
        assert(location + length &lt;= count(self), "OMG again")
        var startIndex = self.startIndex
        startIndex = advance(startIndex, location)
        var res = self.substringFromIndex(startIndex)
        var endIndex = advance(startIndex, length)
        return res.substringToIndex(endIndex)
    }
</code></pre>

<p><img src="/images/2015_07_02_image02.png" title="Test Passed" alt="IMAGE_B" /></p>

<p>For further reading about encoding, I recommend this page. <a href="http://www.objc.io/issues/9-strings/unicode/#utf-8">http://www.objc.io/issues/9-strings/unicode/#utf-8</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surrogate Support for Swift's String]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string/"/>
    <updated>2015-07-02T12:41:54+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string</id>
    <content type="html"><![CDATA[<p>String in Swift does not support UTF16 surrogate in default.</p>

<p>From <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Official Guide</a></p>

<blockquote><p>A Unicode scalar is any Unicode code point in the range U+0000 to U+D7FF inclusive or U+E000 to U+10FFFF inclusive. Unicode scalars do not include the Unicode surrogate pair code points, which are the code points in the range U+D800 to U+DFFF inclusive.</p></blockquote>

<p>Therefore, I wrote a support class for it. :)</p>

<hr />

<p><a href="https://github.com/zh-wang/SwiftySurrogate">SwiftSurrogate on Github</a></p>

<p>Now you can decode Swift String from UTF16 surrogate pair like this.</p>

<pre><code class="swift">    var emoji1 = SwiftySurrogate.decodeFromSurrogatePair(surrogatePair: "D83D:DCC9")
    var emoji2 = SwiftySurrogate.decodeFromSurrogatePair(high: 0xD83C, low: 0xDF80)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generics Enum in Swift]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift/"/>
    <updated>2015-05-20T15:27:01+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift</id>
    <content type="html"><![CDATA[<p>If we want handle different data type, according to the result of calling some APIs. We may need the code like this.</p>

<pre><code class="swift">    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(JsonType)
        case Fail(ErrorMsgType)
    } // compile error
</code></pre>

<p>But the code above cannot be compiled.</p>

<pre><code>    // integer overflows when converted from 'Builtin.Int32' to 'Builtin.Int8'MyPlayground.playground:148:6: error: unimplemented IR generation feature non-fixed multi-payload enum layout
    //     enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
</code></pre>

<h3>How can we actually do this</h3>

<p>We can use <code>Container Class</code>.</p>

<pre><code>    class SuccessContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    class ErrorContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(SuccessContainer&lt;JsonType&gt;)
        case Fail(ErrorContainer&lt;ErrorMsgType&gt;)
    }

    // usage

    func GenAPIResponseSuccess&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Success(SuccessContainer&lt;JsonType&gt;(t: json))
    }

    func GenAPIResponseFail&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(ErrorContainer&lt;ErrorMsgType&gt;(t: errorMsg))
    }

    func callbackFromAPI(response: String) -&gt; APIResponse&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess(response) // can be parsed to json
        } else {
            return GenAPIResponseFail(response) // just a plain error msg
        }
    }

    callbackFromAPI("success. I'm Json")
    callbackFromAPI("404 or something else")
</code></pre>

<p>But it is awful to write bunch of code for creating container classes, for each type you need.</p>

<h3>Better Solution?</h3>

<p>Here is a very useful lib. <a href="https://github.com/robrix/Box">https://github.com/robrix/Box</a></p>

<p>It provide a container class called <code>Box</code></p>

<pre><code>    public final class Box&lt;T&gt;: BoxType, Printable {
        /// Initializes a `Box` with the given value.
        public init(_ value: T) {
            self.value = value
        }


        /// Constructs a `Box` with the given `value`.
        public class func unit(value: T) -&gt; Box&lt;T&gt; {
            return Box(value)
        }


        /// The (immutable) value wrapped by the receiver.
        public let value: T

        /// Constructs a new Box by transforming `value` by `f`.
        public func map&lt;U&gt;(@noescape f: T -&gt; U) -&gt; Box&lt;U&gt; {
            return Box&lt;U&gt;(f(value))
        }


        // MARK: Printable

        public var description: String {
            return toString(value)
        }
    }
</code></pre>

<h3>Finally</h3>

<p>We can rewrite above code into this. Much more elegant.</p>

<pre><code>    enum APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        case Success(Box&lt;JsonType&gt;)
        case Fail(Box&lt;ErrorMsgType&gt;)
    }

    func GenAPIResponseSuccess2&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Success(Box&lt;JsonType&gt;(json))
    }

    func GenAPIResponseFail2&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(Box&lt;ErrorMsgType&gt;(errorMsg))
    }

    func callbackFromAPI2(response: String) -&gt; APIResponse2&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess2(response) // can be parsed to json
        } else {
            return GenAPIResponseFail2(response) // just a plain error msg
        }
    }

    callbackFromAPI2("success. I'm Json")
    callbackFromAPI2("404 or something else")
</code></pre>
]]></content>
  </entry>
  
</feed>
