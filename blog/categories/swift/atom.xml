<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-10-10T21:17:58+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functor, Monad, Applicative in Swift]]></title>
    <link href="http://zh-wang.github.io/blog/2015/10/09/functor-monad-applicative-in-swift/"/>
    <updated>2015-10-09T10:29:12+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/10/09/functor-monad-applicative-in-swift</id>
    <content type="html"><![CDATA[<p>Some Implementation in Swift.</p>

<h3>Functor</h3>

<p>Let $C$ be a constructor which takes a variable as parameter.</p>

<p>$C$ is a <strong>Functor</strong> if $C$ has the following ability.</p>

<p><script type="math/tex; mode=display">
    C[A].map(A \rightarrow B) = C[B]
</script></p>

<p>For example, we can write such a function <code>map</code> for <code>Optional</code>. (Well, swift already has such built-in function.)
&#8220;`swift
    extension Optional {
        func map<U>(f: Wrapped -> U) -> U? {
            switch self {
                case .Some(let x): return f(x)
                case .None: return .None
            }
        }</p>

<pre><code>    // take out the wrapped item
    func toValue() -&gt; Wrapped? {
        switch self {
            case .Some(let x): return x
            case .None: return .None
        }
    }
}

// A -&gt; B
func plusTwo(addend: Int) -&gt; Double {
    return Double(addend) + 2.0
}

// C[A] -&gt; C[B]
Int?.Some(3).map(plusTwo) // Change Optional&lt;Int&gt;(3) into Optional&lt;Double&gt;(5.0)
</code></pre>

<pre><code>
And we can chain functors like this.
</code></pre>

<pre><code>func plusThree(addend: Int) -&gt; Int {
    return addend + 3
}

Int?.Some(3).map(plusThree).map(plusTwo)
</code></pre>

<pre><code>We can also do it like Haskell
</code></pre>

<pre><code>// This is a custom operator
infix operator &lt;^&gt; { associativity left }
func &lt;^&gt;&lt;T, U&gt;(a: T?, f: T -&gt; U) -&gt; U? {
    return a.map(f)
}

Optional.Some(2) &lt;^&gt; plusThree // Int?(5)
Optional.Some(2) &lt;^&gt; plusThree &lt;^&gt; plusThree // Int?(8)
</code></pre>

<pre><code>
### Monad

$C$ is a __Monad__ if $C$ has the following ability.

<script type="math/tex; mode=display">
    C[A].flatmap(A \rightarrow C[B]) = C[B]
</script>
</code></pre>

<pre><code>extension Optional {
    func flatMap&lt;U&gt;(f: Wrapped -&gt; U?) -&gt; U? {
        switch self {
            case .Some(let x): return f(x)
            case .None: return .None
        }
    }
}

func half(a: Int) -&gt; Int? {
    return a % 2 == 0 ? a / 2 : .None
}

Int?.Some(4).flatMap(half) // Int?(2)
</code></pre>

<pre><code>Haskell-like version.
</code></pre>

<pre><code>infix operator &gt;&gt;- { associativity left }

func &gt;&gt;-&lt;T, U&gt;(a: T?, f: T -&gt; U?) -&gt; U? {
    return a.flatMap(f)
}

Int?(3) &gt;&gt;- half // Optional.None
Int?(4) &gt;&gt;- half &gt;&gt;- half // Int?(2)
</code></pre>

<pre><code>### Applicative

$C$ is a __Applicative__ if $C$ has the following ability.

<script type="math/tex; mode=display">
    C[A].apply(C[A \rightarrow B]) = C[B]
</script>
</code></pre>

<pre><code>extension Optional {
    func apply&lt;U&gt;(f: (Wrapped -&gt; U)?) -&gt; U? {
        switch f {
        case .Some(let someF): return self.map(someF)
        case .None: return .None
        }
    }
}

// This is a IntFunction? type
let plusThreeBox = Optional&lt;IntFunction&gt;.Some(plusThree)

Int?.Some(3).apply(plusThreeBox) // Int?(6)
</code></pre>

<pre><code>Haskell-like version.
</code></pre>

<pre><code>infix operator &lt;*&gt; { associativity left }

func &lt;*&gt;&lt;T, U&gt;(a: T?, f: (T -&gt; U)?) -&gt; U? {
    return a.apply(f)
}

func &lt;*&gt;&lt;T, U&gt;(a: [T], f: [T -&gt; U]) -&gt; [U] {
    return a.apply(f)
}

(Optional.Some(2) &lt;*&gt; Optional.Some({ $0 + 3 }))
// =&gt; 5

[1, 2, 3] &lt;*&gt; [ { $0 + 3 }, { $0 * 2 } ]
// =&gt; [ 4, 5, 6, 2, 4, 6 ]
</code></pre>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift String Operations]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/swift-string-operation/"/>
    <updated>2015-07-02T16:24:46+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/swift-string-operation</id>
    <content type="html"><![CDATA[<p>String operations of Swift seems to be easy to handle, but we should take care of them in development.</p>

<p>For example, this is a common code snippet which stays on the top spot, by searching &lsquo;<strong>swift substring</strong>&rsquo; from <a href="www.google.co.jp">www.google.co.jp</a>.</p>

<pre><code class="swift">extension String {
    public func substring(location:Int, length:Int) -&gt; String! {
        return (self as NSString).substringWithRange(NSMakeRange(location, length))
    }
}
</code></pre>

<p>But, it is not correct. <code>NSString</code>&rsquo;s implementation is based on UTF-16 and handing index for it is just confusing.</p>

<p>Take a look at the following test.</p>

<p><img src="/images/2015_07_02_image01.png" title="Test Failed" alt="IMGAE_A" /></p>

<p>Because index in <code>NSString</code> format is different from index in <code>String</code> format. The text is counted as length 2 in <code>NSString</code>, but only 1 in <code>String</code>.</p>

<p>So using <code>substring</code> in <code>NSString</code> only get half of it, from its binary expression. Then certainly, it cannot be decoded correctly.</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Online Guide</a> has a detail explanation for this problem.</p>

<p>We should use <code>String.Index</code> to handle different byte length of each character, and also decomposed and precomposed characters.</p>

<p>Because <code>String</code> in Swift is implemented as <strong>Unicode Scalar</strong>, or <strong>UTF-32</strong>, is always 4-byte long for each character and it default behaviour can handle composed characters.</p>

<pre><code>    public func substring2(location: Int, length:Int) -&gt; String! {
        assert(location &gt;= 0, "OMG")
        assert(location + length &lt;= count(self), "OMG again")
        var startIndex = self.startIndex
        startIndex = advance(startIndex, location)
        var res = self.substringFromIndex(startIndex)
        var endIndex = advance(startIndex, length)
        return res.substringToIndex(endIndex)
    }
</code></pre>

<p><img src="/images/2015_07_02_image02.png" title="Test Passed" alt="IMAGE_B" /></p>

<p>For further reading about encoding, I recommend this page. <a href="http://www.objc.io/issues/9-strings/unicode/#utf-8">http://www.objc.io/issues/9-strings/unicode/#utf-8</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Surrogate Support for Swift's String]]></title>
    <link href="http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string/"/>
    <updated>2015-07-02T12:41:54+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/07/02/surrogate-support-for-swifts-string</id>
    <content type="html"><![CDATA[<p>String in Swift does not support UTF16 surrogate in default.</p>

<p>From <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html">Swift Official Guide</a></p>

<blockquote><p>A Unicode scalar is any Unicode code point in the range U+0000 to U+D7FF inclusive or U+E000 to U+10FFFF inclusive. Unicode scalars do not include the Unicode surrogate pair code points, which are the code points in the range U+D800 to U+DFFF inclusive.</p></blockquote>

<p>Therefore, I wrote a support class for it. :)</p>

<hr />

<p><a href="https://github.com/zh-wang/SwiftySurrogate">SwiftSurrogate on Github</a></p>

<p>Now you can decode Swift String from UTF16 surrogate pair like this.</p>

<pre><code class="swift">    var emoji1 = SwiftySurrogate.decodeFromSurrogatePair(surrogatePair: "D83D:DCC9")
    var emoji2 = SwiftySurrogate.decodeFromSurrogatePair(high: 0xD83C, low: 0xDF80)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generics Enum in Swift]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift/"/>
    <updated>2015-05-20T15:27:01+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/20/generics-enum-in-swift</id>
    <content type="html"><![CDATA[<p>If we want handle different data type, according to the result of calling some APIs. We may need the code like this.</p>

<pre><code class="swift">    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(JsonType)
        case Fail(ErrorMsgType)
    } // compile error
</code></pre>

<p>But the code above cannot be compiled.</p>

<pre><code>    // integer overflows when converted from 'Builtin.Int32' to 'Builtin.Int8'MyPlayground.playground:148:6: error: unimplemented IR generation feature non-fixed multi-payload enum layout
    //     enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
</code></pre>

<h3>How can we actually do this</h3>

<p>We can use <code>Container Class</code>.</p>

<pre><code>    class SuccessContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    class ErrorContainer&lt;T&gt; {
        init (t : T) {
            // ...
        }
    }

    enum APIResponse&lt;JsonType, ErrorMsgType&gt; {
        case Success(SuccessContainer&lt;JsonType&gt;)
        case Fail(ErrorContainer&lt;ErrorMsgType&gt;)
    }

    // usage

    func GenAPIResponseSuccess&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Success(SuccessContainer&lt;JsonType&gt;(t: json))
    }

    func GenAPIResponseFail&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(ErrorContainer&lt;ErrorMsgType&gt;(t: errorMsg))
    }

    func callbackFromAPI(response: String) -&gt; APIResponse&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess(response) // can be parsed to json
        } else {
            return GenAPIResponseFail(response) // just a plain error msg
        }
    }

    callbackFromAPI("success. I'm Json")
    callbackFromAPI("404 or something else")
</code></pre>

<p>But it is awful to write bunch of code for creating container classes, for each type you need.</p>

<h3>Better Solution?</h3>

<p>Here is a very useful lib. <a href="https://github.com/robrix/Box">https://github.com/robrix/Box</a></p>

<p>It provide a container class called <code>Box</code></p>

<pre><code>    public final class Box&lt;T&gt;: BoxType, Printable {
        /// Initializes a `Box` with the given value.
        public init(_ value: T) {
            self.value = value
        }


        /// Constructs a `Box` with the given `value`.
        public class func unit(value: T) -&gt; Box&lt;T&gt; {
            return Box(value)
        }


        /// The (immutable) value wrapped by the receiver.
        public let value: T

        /// Constructs a new Box by transforming `value` by `f`.
        public func map&lt;U&gt;(@noescape f: T -&gt; U) -&gt; Box&lt;U&gt; {
            return Box&lt;U&gt;(f(value))
        }


        // MARK: Printable

        public var description: String {
            return toString(value)
        }
    }
</code></pre>

<h3>Finally</h3>

<p>We can rewrite above code into this. Much more elegant.</p>

<pre><code>    enum APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        case Success(Box&lt;JsonType&gt;)
        case Fail(Box&lt;ErrorMsgType&gt;)
    }

    func GenAPIResponseSuccess2&lt;JsonType, ErrorMsgType&gt;(json : JsonType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Success(Box&lt;JsonType&gt;(json))
    }

    func GenAPIResponseFail2&lt;JsonType, ErrorMsgType&gt;(errorMsg : ErrorMsgType) -&gt; APIResponse2&lt;JsonType, ErrorMsgType&gt; {
        return .Fail(Box&lt;ErrorMsgType&gt;(errorMsg))
    }

    func callbackFromAPI2(response: String) -&gt; APIResponse2&lt;String, String&gt; {
        if (response.hasPrefix("success")) {
            return GenAPIResponseSuccess2(response) // can be parsed to json
        } else {
            return GenAPIResponseFail2(response) // just a plain error msg
        }
    }

    callbackFromAPI2("success. I'm Json")
    callbackFromAPI2("404 or something else")
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Swift Part 14 - Optional Chaining]]></title>
    <link href="http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14/"/>
    <updated>2015-05-12T12:20:35+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/05/12/learning-swift-part-14</id>
    <content type="html"><![CDATA[<h2>===== Full Notes =====</h2>

<h3>Optional Chaining</h3>

<ul>
<li><p><em>Optional chaining</em> is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.</p>

<ul>
<li>If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil.</li>
<li>Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</li>
<li>Optional chaining in Swift is similar to messaging nil in Objective-C, but in a way that works for any type, and that can be checked for success or failure.</li>
</ul>
</li>
<li><p>Optional Chaining as an Alternative to Forced Unwrapping</p>

<ul>
<li><p>Sample of Forced Unwarpping
        class Person {
            var residence: Residence?
        }</p>

<pre><code>    class Residence {
        var numberOfRooms = 1
    }

    let john = Persion()

    let roomCount = john.residence!.numberOfRooms
    // this triggers a runtime error, because residence maybe nil
</code></pre></li>
<li><p>Optional chaining provides an alternative way to access the value of numberOfRooms.</p>

<pre><code>    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
    // prints "Unable to retrieve the number of rooms.

    // Even numberOfRooms is Int, optional chaining will always return it as Int?
</code></pre></li>
</ul>
</li>
<li><p>Defining Model Classes for Optional Chaining</p>

<pre><code>      class Residence {
          var rooms = Room[]()
          var numberOfRooms: Int {
          return rooms.count
          }
          subscript(i: Int) -&gt; Room {
              return rooms[i]
          }
          func printNumberOfRooms() {
              println("The number of rooms is \(numberOfRooms)")
          }
          var address: Address?
      }

      class Room {
          let name: String
          init(name: String) { self.name = name }
      }

      class Address {
          var buildingName: String?
          var buildingNumber: String?
          var street: String?
          func buildingIdentifier() -&gt; String? {
              if buildingName {
                  return buildingName
              } else if buildingNumber {
                  return buildingNumber
              } else {
                  return nil
              }
          }
      }
</code></pre></li>
</ul>


<!-- more -->


<ul>
<li><p>Calling Properties Through Optional Chaining</p>

<ul>
<li><p>It is the same as above</p>

<pre><code>    let john = Person()
    if let roomCount = john.residence?.numberOfRooms {
        println("John's residence has \(roomCount) room(s).")
    } else {
        println("Unable to retrieve the number of rooms.")
    }
</code></pre></li>
</ul>
</li>
<li><p>Calling Methods Through Optional Chaining</p>

<pre><code>      func printNumberOfRooms() {
          println("The number of rooms is \(numberOfRooms)")
      }

      “if john.residence?.printNumberOfRooms() {
          println("It was possible to print the number of rooms.")
      } else {
          println("It was not possible to print the number of rooms.")
      }
      // prints "It was not possible to print the number of rooms.
</code></pre></li>
<li><p>Calling Subscripts Through Optional Chaining</p>

<pre><code>      if let firstRoomName = john.residence?[0].name {
          println("The first room name is \(firstRoomName).")
      } else {
          println("Unable to retrieve the first room name.")
      }
      // prints "Unable to retrieve the first room name.
</code></pre></li>
<li><p>Linking Multiple Levels of Chaining</p>

<ul>
<li>If the type you are trying to retrieve is not optional, it will become optional because of the optional chaining.</li>
<li><p>If the type you are trying to retrieve is already optional, it will not become more optional because of the chaining.</p>

<pre><code>    “if let johnsStreet = john.residence?.address?.street {
        println("John's street name is \(johnsStreet).")
    } else {
        println("Unable to retrieve the address.")
    }
    // prints "Unable to retrieve the address.”
</code></pre></li>
</ul>
</li>
<li><p>Chaining on Methods With Optional Return Values</p>

<pre><code>      if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
          println("John's building identifier is \(buildingIdentifier).")
      }
      // prints "John's building identifier is The Larches.

      “if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {
          println("John's uppercase building identifier is \(upper).")
      }
      // prints "John's uppercase building identifier is THE LARCHES.”
</code></pre></li>
</ul>

]]></content>
  </entry>
  
</feed>
