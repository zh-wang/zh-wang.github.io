<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-05-14T17:04:28+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FB HackerCup 2015 R1 40:CorporateGifting]]></title>
    <link href="http://zh-wang.github.io/blog/2015/04/03/fb-hackcup-2015-r1-40-corporategifting/"/>
    <updated>2015-04-03T23:48:59+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/04/03/fb-hackcup-2015-r1-40-corporategifting</id>
    <content type="html"><![CDATA[<p>Problem definition can be found <a href="https://www.facebook.com/hackercup/problems.php?pid=759650454070547&amp;round=344496159068801">here</a>.<br/>
Need some tricks on recursion.<br/>
And if keep dp size for about $\sqrt{N}$ will cause the program run too LONG!</p>

<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
using namespace std;
#define PB push_back
#define MP make_pair
#define REP(i, n) for (int i(0); i &lt; n; ++i)
#define REP1(i, n) for (int i(1); i &lt; n; ++i)
#define REP1N(i, n) for (int i(1); i &lt;= n; ++i)
#define FOR(i, a, b) for (int i(a); i &lt;= b; ++i)

typedef long long ll;
typedef vector&lt;ll&gt; vll;
typedef vector&lt;int&gt; vi;
typedef vector&lt;vi&gt; vvi;
typedef vector&lt;bool&gt; vb;
typedef vector&lt;vb&gt; vvb;
typedef pair&lt;int, int&gt; pii;

int tc;
int n;
int parentIndex;

struct node {
    node() {
        child = vector&lt;int&gt;();
    }
    vector&lt;int&gt; child;
};

node nodes[200001];
pii best1[200001];
pii best2[200001];

bool sort_bests(const pii&amp; left, const pii&amp; right) {
    if (left.second == right.second) {
        return left.first &lt; right.first;
    } else {
        return left.second &lt; right.second;
    }
}

void solve(int depth, int rootIndex) {
    node* root = &amp;nodes[rootIndex];
    int csize = root-&gt;child.size();
    REP(j, csize) {
        solve(++depth, root-&gt;child[j]);
    }

    int maxColor = ceil(sqrt(n));
    REP1N(rootColor, maxColor) { // find color should be choosen for root
        int _res = 0; // subtree sum of root, when picking rootColor
        REP(j, csize) { // for each child
            int childIndex = root-&gt;child[j];
            node* child = &amp;nodes[childIndex];
            int __res = 0;
            if (rootColor == best1[childIndex].first)
                __res += best2[childIndex].second;
            else
                __res += best1[childIndex].second;
            _res += __res;
        }
        _res += rootColor;
        pii new_best = MP(rootColor, _res);
        if (sort_bests(new_best, best1[rootIndex])) {
            best2[rootIndex] = best1[rootIndex];
            best1[rootIndex] = new_best;
        } else if (sort_bests(new_best, best2[rootIndex])) {
            best2[rootIndex] = new_best;
        }
    }
}

int main(int argc, char* argv[]) {
    cin &gt;&gt; tc;
    REP(i, tc) {
        cin &gt;&gt; n;
        REP(j, 200001) {
            nodes[j] = node();
            best1[j] = MP(INT_MAX, INT_MAX);
            best2[j] = MP(INT_MAX, INT_MAX);
        }
        REP(j, n) {
            cin &gt;&gt; parentIndex;
            nodes[parentIndex].child.PB(j + 1);
        }
        solve(1, 1);
        int res = best1[1].second &gt; best2[1].second ? best2[1].second : best1[1].second;
        cout &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FB HackerCup 2015 R1 25:Autocomplete]]></title>
    <link href="http://zh-wang.github.io/blog/2015/04/02/fb-hackercup-2015-r1-25-autocomplete/"/>
    <updated>2015-04-02T18:16:03+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/04/02/fb-hackercup-2015-r1-25-autocomplete</id>
    <content type="html"><![CDATA[<p>Problem definition can be found <a href="https://www.facebook.com/hackercup/problems.php?pid=313229895540583&amp;round=344496159068801">here</a>.<br/>
This is a basic problem which can be solved directly by a Tri-tree.</p>

<pre><code class="cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
#include &lt;list&gt;
#include &lt;sstream&gt;
using namespace std;
#define PB push_back
#define MP make_pair
#define REP(i, n) for (int i(0); i &lt; n; ++i)
#define REP1(i, n) for (int i(1); i &lt; n; ++i)
#define FOR(i, a, b) for (int i(a); i &lt;= b; ++i)

struct node {
    node() {
        childs = new node*[26];
        REP(i, 26) childs[i] = NULL;
    }
    node** childs;
};

int tc;
int n;
string word;

int findWordAndBuildTree(node* root, string word) {
    node* p = root;
    int i = 0;
    int res = 0;
    bool found = false;
    REP(i, word.length()) {
        if (p-&gt;childs[word[i]-'a'] == NULL) {
            if (!found) {
                res = i + 1;
                found = true;
            }
            p-&gt;childs[word[i]-'a'] = new node();
        }
        p = p-&gt;childs[word[i]-'a'];
    }
    return res;
}

int main(int argc, char* argv[]) {
    cin &gt;&gt; tc;
    REP(i, tc) {
        cin &gt;&gt; n;
        node* root = new node();
        int res = 0;
        REP(j, n) {
            cin &gt;&gt; word;
            res += findWordAndBuildTree(root, word);
        }
        cout &lt;&lt; res &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Analysis of PROB Milking Cows]]></title>
    <link href="http://zh-wang.github.io/blog/2015/03/15/analysis-of-prob-milking-cows/"/>
    <updated>2015-03-15T21:14:14+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/03/15/analysis-of-prob-milking-cows</id>
    <content type="html"><![CDATA[<h2>Description</h2>

<p>(From train.usaco.org) Three farmers rise at 5 am each morning and head for the barn to milk three cows. The first farmer begins milking his cow at time 300 (measured in seconds after 5 am) and ends at time 1000. The second farmer begins at time 700 and ends at time 1200. The third farmer begins at time 1500 and ends at time 2100. The longest continuous time during which at least one farmer was milking a cow was 900 seconds (from 300 to 1200). The longest time no milking was done, between the beginning and the ending of all milking, was 300 seconds (1500 minus 1200).</p>

<p>Your job is to write a program that will examine a list of beginning and ending times for N (1 &lt;= N &lt;= 5000) farmers milking N cows and compute (in seconds):</p>

<p>The longest time interval at least one cow was milked.
The longest time interval (after milking starts) during which no cows were being milked.</p>

<pre><code>SAMPLE INPUT (file milk2.in)
3
300 1000
700 1200
1500 2100
</code></pre>

<pre><code>SAMPLE OUTPUT (file milk2.out)
900 300
</code></pre>

<h2>Analysis</h2>

<p>A straight-forward, brute-force solution is to keep a large array $k$, with each element $k_i$ is a boolean value indicates whether at least one cow is being milked at time $i$. Then travel from the start to the end to get the answer.</p>

<!-- more -->


<h2>Source</h2>

<pre><code class="cpp">/*
ID: viennak1
PROB: milk2
LANG: C++
*/

// Section 1.2 PROB Milking Cows

#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
using namespace std;

int N;
int s[5000],t[5000];
bool k[1000005];
int res1,res2;
int main(){
    ofstream fout ("milk2.out");
    ifstream fin ("milk2.in");
    fin&gt;&gt;N;
    for(int i=0;i&lt;N;i++) fin&gt;&gt;s[i]&gt;&gt;t[i];
    for(int i=N-1;i&gt;0;i--) for(int j=0;j&lt;i;j++){
        if(s[j]&gt;s[j+1]) swap(s[j],s[j+1]),swap(t[j],t[j+1]);
        else if(s[j]==s[j+1] &amp;&amp; t[j]&lt;t[j+1]) swap(t[j],t[j+1]);
    }
    int last=0;
    for(int i=0;i&lt;N;i++){
        if(s[i]&lt;=last){
            if(t[i]&lt;=last) continue;
            for(int j=last;j&lt;t[i];j++) k[j]=true;
            last=t[i];
        }
        else{
            for(int j=s[i];j&lt;t[i];j++) k[j]=true;
            last=t[i];
        }
    }
    bool mark=false;
    int end=0; for(int i=0;i&lt;N;i++) end=max(end,t[i]);
    int start=0;
    if(s[0]&gt;500) start=last=500, res2=s[0]-500;
    else start=last=s[0],mark=true;
    for(int i=start;i&lt;=end+1;i++){
        if(mark==k[i]) continue;
        if(!mark) res2=max(res2,i-last), last=i, mark=true;
        else res1=max(res1,i-last), last=i, mark=false;
    }
    fout&lt;&lt;res1&lt;&lt;" "&lt;&lt;res2&lt;&lt;endl;
    //for(int i=0;i&lt;21;i++) cout&lt;&lt;k[i]&lt;&lt;" ";
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Analysis of PROB Broken Necklace]]></title>
    <link href="http://zh-wang.github.io/blog/2015/02/25/usaco-prob-broken-necklace/"/>
    <updated>2015-02-25T17:58:16+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/02/25/usaco-prob-broken-necklace</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of PROB Broken Necklace, one of USA Computer Olympiad&rsquo;s training problems.<br/>
Just doing some disposal on my old stuff.</p>

<h2>Description</h2>

<p>You have a necklace of N red, white, or blue beads (3&lt;=N&lt;=350) some of which are red, others blue, and others white, arranged at random. Here are two examples for n=29:</p>

<pre><code>            1 2                               1 2
        r b b r                           b r r b
      r         b                       b         b
     r           r                     b           r
    r             r                   w             r
   b               r                 w               w
  b                 b               r                 r
  b                 b               b                 b
  b                 b               r                 b
   r               r                 b               r
    b             r                   r             r
     b           r                     r           r
       r       r                         r       b
         r b r                             r r w
        Figure A                         Figure B
                    r red bead
                    b blue bead
                    w white bead
</code></pre>

<p>The beads considered first and second in the text that follows have been marked in the picture.</p>

<p>The configuration in Figure A may be represented as a string of b&rsquo;s and r&rsquo;s, where b represents a blue bead and r represents a red one, as follows: brbrrrbbbrrrrrbrrbbrbbbbrrrrb .</p>

<p>Suppose you are to break the necklace at some point, lay it out straight, and then collect beads of the same color from one end until you reach a bead of a different color, and do the same for the other end (which might not be of the same color as the beads collected before this).</p>

<p>Determine the point where the necklace should be broken so that the most number of beads can be collected.</p>

<!--more-->


<h2>Analysis</h2>

<p>Given an input string &lsquo;wwwbbrwrbrbrrbrbrwrwwrbwrwrrb&rsquo;, we concatenate it with itself, result in &lsquo;wwwbbrwrbrbrrbrbrwrwwrbwrwrrbwwwbbrwrbrbrrbrbrwrwwrbwrwrrb&rsquo;. This trick, working on handling minus or over-length index is easier.</p>

<ol>
<li><p>Brute force solution.</p>

<p> For each index $a_i$ as a start, if $a_{i+1}$ can be picked into the longest substring, we pick it then do this again on $a_{i+1}$. Note that, if $a_i$ is w, we must treat it as b and r, one by one. We do N times of picking attempt for each $a_i$. Therefore complexity is O(N<sup>2</sup>). Just a straight forward solution.</p></li>
<li><p>DP solution.</p>

<p> We denote substring composed by successive r, which <strong>ends</strong> at index $i$ to $t_{i,r}$.</p></li>
</ol>


<p><script type="math/tex; mode=display">
    t<em>{i,r} = \begin{cases}
        t</em>{i-1,r} + 1 &amp; \text{if $a_i$ is r or w} \
        0 &amp; \text{if $a_i$ is b or $i$ > N}
    \end{cases}
</script></p>

<p>Similarly, we denote substring composed by successive b, which <strong>ends</strong> at index $i$ to $t_{i,b}$.</p>

<p><script type="math/tex; mode=display">
    t<em>{i,b} = \begin{cases}
        t</em>{i-1,b} + 1 &amp; \text{if $a_i$ is b or w} \
        0 &amp; \text{if $a_i$ is r or $i$ > N}
    \end{cases}
</script></p>

<p>On the other hand, we denote substring composed by successive r, which <strong>starts</strong> at index $i$ to $s_{i,r}$.</p>

<p><script type="math/tex; mode=display">
    s<em>{i,r} = \begin{cases}
        s</em>{i+1,r} + 1 &amp; \text{if $a_i$ is r or w} \
        0 &amp; \text{if $a_{i-1}$ is b or $i = 0$}
    \end{cases}
</script></p>

<p>And substring composed by successive b, which <strong>starts</strong> at index $i$ to $t_{i,b}$.</p>

<p><script type="math/tex; mode=display">
    s<em>{i,b} = \begin{cases}
        s</em>{i+1,b} + 1 &amp; \text{if $a_i$ is b or w} \
        0 &amp; \text{if $a_{i-1}$ is r or $i = 0$}
    \end{cases}
</script></p>

<p>For each index $a_i$, $\max \{s_{i,r}, s_{i,b} \} + \max \{t_{i,r}, t_{i,b} \}$ is the length of longest substring if we break it at index $i$. We do this for N times, the greatest one is the answer. Complexity of this algorithm is O(n).</p>

<h2>Source Code of DP Solution</h2>

<pre><code class="cpp">/*
ID: viennak1
PROB: beads
LANG: C++
*/

// Section 1.1 PROB Broken Necklace

#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cassert&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
using namespace std;

int N,res;
int ENDS[700][2],STARTS[700][2];
string s;
int main(){
    ofstream fout ("beads.out");
    ifstream fin ("beads.in");
    fin&gt;&gt;N; fin&gt;&gt;s;
    int L=s.length();
    s=s+s;
    if(s[0]=='r') ENDS[0][0]=1;
    else if(s[0]=='b') ENDS[0][1]=1;
    else ENDS[0][0]=ENDS[0][1]=1;
    for(int i=1;i&lt;L*2;i++){
        if(s[i]=='r') ENDS[i][0]=ENDS[i-1][0]+1;
        if(s[i]=='b') ENDS[i][1]=ENDS[i-1][1]+1;
        if(s[i]=='w') ENDS[i][0]=ENDS[i-1][0]+1,ENDS[i][1]=ENDS[i-1][1]+1;
    }
    if(s[2*L-1]=='r') STARTS[2*L-1][0]=1;
    else if(s[2*L-1]=='b') STARTS[2*L-1][1]=1;
    else STARTS[2*L-1][0]=STARTS[2*L-1][1]=1;
    for(int i=2*L-2;i&gt;=0;i--){
        if(s[i]=='r') STARTS[i][0]=STARTS[i+1][0]+1;
        if(s[i]=='b') STARTS[i][1]=STARTS[i+1][1]+1;
        if(s[i]=='w') STARTS[i][0]=STARTS[i+1][0]+1,STARTS[i][1]=STARTS[i+1][1]+1;
    }
    for(int i=0;i&lt;2*L-1;i++)
        res=max(res, max(ENDS[i][0],ENDS[i][1])+max(STARTS[i+1][0],STARTS[i+1][1]));
    if(res&gt;L) fout&lt;&lt;L&lt;&lt;endl;
    else fout&lt;&lt;res&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codility - Phosphorus - 2014]]></title>
    <link href="http://zh-wang.github.io/blog/2014/08/14/codility-phosphorus-2014/"/>
    <updated>2014-08-14T15:04:36+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/08/14/codility-phosphorus-2014</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of <a href="https://codility.com/programmers/challenges/">Codility - Prosphorus 2014 Challenge</a>.</p>

<ul>
<li>This problem is, finding the minimal number of guards to set in a tree which can prevent prisoners escaping to tree leaves.</li>
<li>Time bound and space bound are both O(N).</li>
</ul>


<h2>Analysis</h2>

<ul>
<li>Create a <code>Node</code> structure, holding its parent index, a boolean value presenting it is a prisoner or not. Then a boolean value presenting whether prisoners can escape down to leaves, and another boolean value presenting whether prisoners can escape from the root.</li>
<li>Depth-First-Search from node 0.</li>
<li>Adjust the result according to node 0&rsquo;s state. Done.</li>
<li>A classic DFS holds time bound and space bound.</li>
</ul>


<pre><code class="java">
    static int N = 200003;

    boolean[] visited = new boolean[N];
    Node[] nodes = new Node[N];
    int res = 0;

    public int solution(int A[], int B[], int C[]) {
        for (int i = 0; i &lt; A.length; i++) {
            if (nodes[A[i]] == null) nodes[A[i]] = new Node();
            if (nodes[B[i]] == null) nodes[B[i]] = new Node();
            nodes[A[i]].tlist.add(B[i]);
            nodes[B[i]].tlist.add(A[i]);
        }

        if (C.length == 0) return 0;

        // if a prison is on leaf(exit), then we cannot stop them escaping
        for (int i = 0; i &lt; C.length; i++) {
            if (isLeaf(nodes[C[i]])) {
                return -1;
            }
            nodes[C[i]].isPrisoner = true;
        }

        dfs(0);

        // if node 0 is has only one path, then it is an exit. 
        // we should set a guard if node 0 is exit &amp;&amp; prisoners can escape to root
        return nodes[0].hasEscapeRoot &amp;&amp; nodes[0].tlist.size() == 1 ? res + 1 : res;
    }

    void dfs(int nodeIndex) {
        visited[nodeIndex] = true;
        Node node = nodes[nodeIndex];

        for (int i = 0; i &lt; node.tlist.size(); i++) {
            int nextNodeIndex = node.tlist.get(i);
            if (!visited[nextNodeIndex]) {
                nodes[nextNodeIndex].parentIndex = nodeIndex;
                dfs(nextNodeIndex);
            }
        }

        if (nodeIndex != node.parentIndex &amp;&amp; (isLeaf(node)))  return;

        int n = 0;
        int escapesLeaf = 0;
        int escapesRoot = 0;
        for (int i = 0; i &lt; node.tlist.size(); ++i) {
            int next = node.tlist.get(i);
            if (node.parentIndex == next) continue;
            n++;
            if (nodes[next].hasEscapeLeaf) escapesLeaf++;
            if (nodes[next].hasEscapeRoot) escapesRoot++;
        }

        if (node.isPrisoner) { // if root is PRISONER,
            node.hasEscapeLeaf = false; // then it must not have escape paths to leaf
            node.hasEscapeRoot = true; // but it can escape to root
            res += escapesLeaf; // set guards on those leaves
        } else { // if root is NOT PRISONER, 
            if (escapesLeaf == n) { // all subtrees has escape to leaf
                // it a empty subtree, do nothing
            } else if (escapesLeaf == 0) { // no subtree has escape to leaf
                // then we do NOT need a guard here
                node.hasEscapeLeaf = false; // set no escape to leaf
                if (escapesRoot &gt; 0) { // if at least one subtree has prisoner can escape to root
                    node.hasEscapeRoot = true;
                }
            } else { // has SOME escape path
                if (escapesRoot == 0) { // if no prisoner can escape to root
                    // then we do NOT need a guard here
                    node.hasEscapeLeaf = true; // because it has escape paths
                    node.hasEscapeRoot = false; // obviously
                } else { // if some prisoner can escape to root
                    res++; // set guard here, prevent them escape to leaves through this node
                    node.hasEscapeLeaf = false; // we set the guard, so there is no escape path to leaves
                    node.hasEscapeRoot = false; // as above
                }
            }
        }

    }

    boolean isLeaf(Node node) {
        if (node.tlist.size() == 1) return true;
        else return false;
    }

    class Node {
        int parentIndex;
        boolean isPrisoner = false;
        boolean hasEscapeLeaf = true;
        boolean hasEscapeRoot = false;
        List&lt;Integer&gt; tlist = new ArrayList&lt;Integer&gt;();
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
