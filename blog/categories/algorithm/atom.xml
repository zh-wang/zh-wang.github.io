<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Welcome to FutureAppLaboratory]]></title>
  <link href="http://zh-wang.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://zh-wang.github.io/"/>
  <updated>2015-02-26T10:32:54+09:00</updated>
  <id>http://zh-wang.github.io/</id>
  <author>
    <name><![CDATA[viennakanon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Analysis of PROB Broken Necklace]]></title>
    <link href="http://zh-wang.github.io/blog/2015/02/25/usaco-prob-broken-necklace/"/>
    <updated>2015-02-25T17:58:16+09:00</updated>
    <id>http://zh-wang.github.io/blog/2015/02/25/usaco-prob-broken-necklace</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of PROB Broken Necklace, one of USA Computer Olympiad&rsquo;s training problems.<br/>
I&rsquo;m just doing some disposal on my old stuff.</p>

<h2>Description</h2>

<p>You have a necklace of N red, white, or blue beads (3&lt;=N&lt;=350) some of which are red, others blue, and others white, arranged at random. Here are two examples for n=29:</p>

<pre><code>            1 2                               1 2
        r b b r                           b r r b
      r         b                       b         b
     r           r                     b           r
    r             r                   w             r
   b               r                 w               w
  b                 b               r                 r
  b                 b               b                 b
  b                 b               r                 b
   r               r                 b               r
    b             r                   r             r
     b           r                     r           r
       r       r                         r       b
         r b r                             r r w
        Figure A                         Figure B
                    r red bead
                    b blue bead
                    w white bead
</code></pre>

<p>The beads considered first and second in the text that follows have been marked in the picture.</p>

<p>The configuration in Figure A may be represented as a string of b&rsquo;s and r&rsquo;s, where b represents a blue bead and r represents a red one, as follows: brbrrrbbbrrrrrbrrbbrbbbbrrrrb .</p>

<p>Suppose you are to break the necklace at some point, lay it out straight, and then collect beads of the same color from one end until you reach a bead of a different color, and do the same for the other end (which might not be of the same color as the beads collected before this).</p>

<p>Determine the point where the necklace should be broken so that the most number of beads can be collected.</p>

<h2>Analysis</h2>

<p>Given an input string &lsquo;wwwbbrwrbrbrrbrbrwrwwrbwrwrrb&rsquo;, we concatenate it with itself, result in &lsquo;wwwbbrwrbrbrrbrbrwrwwrbwrwrrbwwwbbrwrbrbrrbrbrwrwwrbwrwrrb&rsquo;. This trick breaks index circling.</p>

<p>Then problem is now that, given an input string composed by &lsquo;r&rsquo;, &lsquo;b&rsquo; and &lsquo;w&rsquo;, find the length of the longest path which composed by successive &lsquo;r&rsquo; and &lsquo;b&rsquo;, while &lsquo;w&rsquo; can be treated either &lsquo;r&rsquo; or &lsquo;b&rsquo;. For convenience, we define input string as $s_1, s_2, cdots, s_k$.</p>

<ol>
<li><p>A brute force solution.</p>

<pre><code> &lt;TODO&gt;
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codility - Phosphorus - 2014]]></title>
    <link href="http://zh-wang.github.io/blog/2014/08/14/codility-phosphorus-2014/"/>
    <updated>2014-08-14T15:04:36+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/08/14/codility-phosphorus-2014</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of <a href="https://codility.com/programmers/challenges/">Codility - Prosphorus 2014 Challenge</a>.</p>

<ul>
<li>This problem is, finding the minimal number of guards to set in a tree which can prevent prisoners escaping to tree leaves.</li>
<li>Time bound and space bound are both O(N).</li>
</ul>


<h2>Analysis</h2>

<ul>
<li>Create a <code>Node</code> structure, holding its parent index, a boolean value presenting it is a prisoner or not. Then a boolean value presenting whether prisoners can escape down to leaves, and another boolean value presenting whether prisoners can escape from the root.</li>
<li>Depth-First-Search from node 0.</li>
<li>Adjust the result according to node 0&rsquo;s state. Done.</li>
<li>A classic DFS holds time bound and space bound.</li>
</ul>


<pre><code class="java">
    static int N = 200003;

    boolean[] visited = new boolean[N];
    Node[] nodes = new Node[N];
    int res = 0;

    public int solution(int A[], int B[], int C[]) {
        for (int i = 0; i &lt; A.length; i++) {
            if (nodes[A[i]] == null) nodes[A[i]] = new Node();
            if (nodes[B[i]] == null) nodes[B[i]] = new Node();
            nodes[A[i]].tlist.add(B[i]);
            nodes[B[i]].tlist.add(A[i]);
        }

        if (C.length == 0) return 0;

        // if a prison is on leaf(exit), then we cannot stop them escaping
        for (int i = 0; i &lt; C.length; i++) {
            if (isLeaf(nodes[C[i]])) {
                return -1;
            }
            nodes[C[i]].isPrisoner = true;
        }

        dfs(0);

        // if node 0 is has only one path, then it is an exit. 
        // we should set a guard if node 0 is exit &amp;&amp; prisoners can escape to root
        return nodes[0].hasEscapeRoot &amp;&amp; nodes[0].tlist.size() == 1 ? res + 1 : res;
    }

    void dfs(int nodeIndex) {
        visited[nodeIndex] = true;
        Node node = nodes[nodeIndex];

        for (int i = 0; i &lt; node.tlist.size(); i++) {
            int nextNodeIndex = node.tlist.get(i);
            if (!visited[nextNodeIndex]) {
                nodes[nextNodeIndex].parentIndex = nodeIndex;
                dfs(nextNodeIndex);
            }
        }

        if (nodeIndex != node.parentIndex &amp;&amp; (isLeaf(node)))  return;

        int n = 0;
        int escapesLeaf = 0;
        int escapesRoot = 0;
        for (int i = 0; i &lt; node.tlist.size(); ++i) {
            int next = node.tlist.get(i);
            if (node.parentIndex == next) continue;
            n++;
            if (nodes[next].hasEscapeLeaf) escapesLeaf++;
            if (nodes[next].hasEscapeRoot) escapesRoot++;
        }

        if (node.isPrisoner) { // if root is PRISONER,
            node.hasEscapeLeaf = false; // then it must not have escape paths to leaf
            node.hasEscapeRoot = true; // but it can escape to root
            res += escapesLeaf; // set guards on those leaves
        } else { // if root is NOT PRISONER, 
            if (escapesLeaf == n) { // all subtrees has escape to leaf
                // it a empty subtree, do nothing
            } else if (escapesLeaf == 0) { // no subtree has escape to leaf
                // then we do NOT need a guard here
                node.hasEscapeLeaf = false; // set no escape to leaf
                if (escapesRoot &gt; 0) { // if at least one subtree has prisoner can escape to root
                    node.hasEscapeRoot = true;
                }
            } else { // has SOME escape path
                if (escapesRoot == 0) { // if no prisoner can escape to root
                    // then we do NOT need a guard here
                    node.hasEscapeLeaf = true; // because it has escape paths
                    node.hasEscapeRoot = false; // obviously
                } else { // if some prisoner can escape to root
                    res++; // set guard here, prevent them escape to leaves through this node
                    node.hasEscapeLeaf = false; // we set the guard, so there is no escape path to leaves
                    node.hasEscapeRoot = false; // as above
                }
            }
        }

    }

    boolean isLeaf(Node node) {
        if (node.tlist.size() == 1) return true;
        else return false;
    }

    class Node {
        int parentIndex;
        boolean isPrisoner = false;
        boolean hasEscapeLeaf = true;
        boolean hasEscapeRoot = false;
        List&lt;Integer&gt; tlist = new ArrayList&lt;Integer&gt;();
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codility - Silicium - 2014]]></title>
    <link href="http://zh-wang.github.io/blog/2014/07/22/codility-silicium-2014/"/>
    <updated>2014-07-22T17:02:26+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/07/22/codility-silicium-2014</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of <a href="https://codility.com/programmers/challenges/">Codility - Silicium 2014 Challenge</a>.</p>

<ul>
<li>The problem is, finding the k-th largest piece of cake after cutting a big cake with straight cuts.</li>
<li>The longest edge of a cake piece is 10000.</li>
<li>Time bound is O(N * log(N + X + Y)), where N is the number of cuts, X and Y are largest size of the cake.</li>
<li>Space bound is O(N).</li>
</ul>


<h2>Analysis</h2>

<p>In order to find the k-th element is an array of set of elements, we can always do binary search. Find a middle elements, calculate the rank, do partition if needed, recursively.</p>

<ul>
<li>First, we calculate length of each edges, the sort them by their length.</li>
<li>Then do a traditional binary search.</li>
</ul>


<p>The only <strong>interesting</strong> thing is that, for calculating the rank of a element in 2-d array, we need O(N) time.<br/>
But in this problem, after we sort edges in <em>x</em> and <em>y</em>, we can do rank calculation in O(N) time, as implemented in <code>fastPartition</code> method.</p>

<p>(Hint: after we sort the edges, we can ensure that elements in left-bottom are always equal or smaller than elements in right-top. We just need to find the smallest element of each column, follow the red arrow, in O(N) time)</p>

<p><img src="/images/2014_07_22_illustration.png" title="hint" alt="hint" /></p>

<!-- more -->


<pre><code class="java">    int N;
    int[] largerEqualList;

    private int fastPartition(int target, int[] x, int[] y) {

        // find the element equal or larger than target in left-most column
        int nx = 0, ny = 0;
        int low = 0;
        int high = N;
        while (low &lt;= high &amp;&amp; low &lt; N) {
            int mid = (low + high) / 2;
            if (x[nx] * y[mid] &lt; target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        ny = low;

        largerEqualList[nx] = ny;

        // search elements' index by red arrow mentioned above
        while (++nx &lt; N) {
            while (ny - 1 &gt;= 0 &amp;&amp; x[nx] * y[ny - 1] &gt;= target) {
                --ny;
            }
            largerEqualList[nx] = ny;
        }

        // get the rank of target
        int rank = 0;
        for (int i = 0; i &lt; N; i++) {
            rank += N - largerEqualList[i];
        }

        return rank;
    }

    public int solution(int X, int Y, int K, int [] A, int [] B) {

        int [] x = new int[A.length + 1];
        int [] y = new int[A.length + 1];

        for (int i = 0; i &lt; A.length + 1; i++) {
            x[i] = (i &lt; A.length ? A[i] : X) - (i &gt; 0 ? A[i - 1] : 0);
        }

        for (int i = 0; i &lt; A.length + 1; i++) {
            y[i] = (i &lt; A.length ? B[i] : Y) - (i &gt; 0 ? B[i - 1] : 0);
        }

        Arrays.sort(x);
        Arrays.sort(y);

        N = x.length; 

        largerEqualList = new int[N];

        int low = x[0] * y[0];
        int high = x[N - 1] * y[N - 1];
        int rank = K;

        // binary search
        while (low &lt;= high) {
            int mid = (low + high) / 2;
            int crank = fastPartition(mid, x, y);

            if (crank &gt;= rank) {
                low = mid + 1;
            } else if (crank &lt; rank) {
                high = mid - 1;
            }
        }

        return high;
    }
</code></pre>

<p>Each <code>fastPartition</code> cost O(N) time, and we do log(10000 * 10000) times. So the total time is O(N * log(10000 * 10000). There is no X and Y occurs. <br/>
Note that even a traditional O(N<sup>2</sup>) time partition could pass system test. :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codility - Aluminium 2014 - Part 2]]></title>
    <link href="http://zh-wang.github.io/blog/2014/06/20/codility-aluminium-2014-p2/"/>
    <updated>2014-06-20T11:17:21+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/06/20/codility-aluminium-2014-p2</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of <a href="https://codility.com/programmers/challenges/">Codility - Aluminium 2014 Challenge</a>, Part 2.</p>

<p>In <a href="http://zh-wang.github.io/blog/2014/06/18/codility-aluminium-2014/">Part 1</a>, we introduced a solution for CLASSIC maximal subarray problem.<br/>
Now we&rsquo;ll make a solution for the <strong>swap</strong> version.</p>

<!-- more -->


<h2>Analysis</h2>

<p>We want to use the strategy described in <a href="http://zh-wang.github.io/blog/2014/06/18/codility-aluminium-2014/">Part 1</a>.</p>

<h3>1. Split input array</h3>

<p>We split given array <script type="math/tex"> a_0, a_1, \cdots, a_n-1 </script> by index <script type="math/tex"> i </script>. Then we get subarray <script type="math/tex"> L_1 = {a_0, a_1, \cdots, a_i} </script> and <script type="math/tex"> L_2 = {a_i+1, a_i+2, \cdots, a_n-1} </script>.</p>

<h3>2. Limited Swap</h3>

<p>Note that, we consider that a swap of $a_j$ and $a_k$ only occurs in array $L_1$, $0 \leq j &lt; k &lt; i$. Why? If such a swap occurs in $L_2$, we just reverse the input array, then do the same calculation on it again to get the result.</p>

<p>Now we want to minimize partial sum of <script type="math/tex"> L_1 </script>(after a swap) and <script type="math/tex"> L_2 </script>, as we did in Part 1.</p>

<h3>3. Calculation on $L_1$(after a swap)</h3>

<p>The principle is, for each $a_k$, we should swap $a_k$ with $a_j$, which is the greatest member in $a_0, a_1, \cdots, a_k-1$. We can do this step by step.</p>

<p>● Calculate partial sum of $L_1$, stored in $psum$ array.</p>

<p><script type="math/tex; mode=display">
    psum_x = partial_sum(x) = \sum_{k=0}^x a_k , 0 \leq k \leq x &lt; i
</script></p>

<p>● Calculate the greatest member&rsquo;s value in $a_0, a_1, \cdots, a_x$</p>

<p><script type="math/tex; mode=display">
    pmax_x = \max { a_0, a_1, \cdots, a_x } , 0 \leq x &lt; i
</script></p>

<p>● We define $minsub(x)$ as the possible minimal partial sum we could get for $a_0, a_1, \cdots, a_x$, by remove(swap out) the greatest member.</p>

<p><script type="math/tex; mode=display">
    minsub(x) = \begin{cases}
        0 &amp; (x = 0) \
        \min { minsub(x-1), psum_x - pmax_x } &amp; (otherwise)
    \end{cases}
</script></p>

<p>● Last, we define $L_1(x)$ as the possible minimal partial sum after swap in $a_x$. Note that for $x=0$, there is only one element in partial array $a_0$, so we cannot make a swap. We just store $a_0$&rsquo;s value as minimal partial sum.</p>

<p><script type="math/tex; mode=display">
    L_1(x) = \begin{cases}
        a_0 &amp; (x = 0) \
        \min { L_1(x-1), minsub(x) + a_x } &amp; (otherwise)
    \end{cases}
</script></p>

<h3>Calculation on $L_2$</h3>

<p>Calculation on $L_2$ is the same as we described in Part 1.</p>

<h3>Merge</h3>

<p>Use results of <script type="math/tex"> L_1 </script> and <script type="math/tex"> L_2 </script>. The largest one is the answer.</p>

<p>Because calculation above is on 1-d array, time and space complexity are O(n).</p>

<p>Code
&#8220;`java</p>

<pre><code>public int solution(int[] inputs) {

    List&lt;Integer&gt;data = new ArrayList&lt;Integer&gt;();
    List&lt;Integer&gt; rdata = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; inputs.length; i++) data.add(inputs[i]);
    for (int i = 0; i &lt; inputs.length; i++) rdata.add(inputs[inputs.length - 1 - i]);

    int r1 = cal(data);
    int r2 = cal(rdata);

    int result = Math.max(r1, r2);
    // result equals 0 means no subarray have sum larger than 0,
    // we need to choose a largest negative element.
    if (result == 0) {
        return Collections.max(data);
    } else {
        return result;
    }
}

private int cal(List&lt;Integer&gt; data) {
    int n = data.size();
    int sum = 0;
    for (Integer integer : data) sum += integer;

    List&lt;Integer&gt; psum = partial_sum(data, compAdd);
    List&lt;Integer&gt; pmax = partial_sum(data, compMax);
    List&lt;Integer&gt; sub = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; n; i++) {
        sub.add(psum.get(i) - pmax.get(i));
    }

    List&lt;Integer&gt; min_sub = partial_sum(sub, compMin);
    List&lt;Integer&gt; L1 = new ArrayList&lt;Integer&gt;();
    for (int i = 0; i &lt; n; i++) {
        L1.add(
                Math.min(
                        (i - 1 &gt;= 0 ? min_sub.get(i - 1) : 0) + data.get(i), 
                        (i - 1 &gt;= 0 ? L1.get(i - 1) : 0)
                        )
                );
    }

    Collections.reverse(data);
    List&lt;Integer&gt; r_psum = partial_sum(data, compAdd);
    List&lt;Integer&gt; L2 = partial_sum(r_psum, compMin);
    Collections.reverse(L2);

    // We can split array into L1 and L2 at index i form 0 to n - 1. We just take the largest.
    int best = 0;
    for (int i = 0; i &lt; n; i++) {
        best = Math.max(best, sum - L1.get(i) - (i + 1 &gt;= n ? 0 : L2.get(i+1)) );
    }
    return best;
}

private List&lt;Integer&gt; partial_sum(List&lt;Integer&gt; data, Comparator&lt;Integer&gt; comparator) {
    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
    if (data.size() == 0) {
        return null;
    }
    res.add(data.get(0));
    for (int i = 1; i &lt; data.size(); i++) {
        Integer lastValue = res.get(i - 1);
        Integer currentValue = data.get(i);
        res.add(comparator.compare(lastValue, currentValue));
    }
    return res;
}

Comparator&lt;Integer&gt; compAdd = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1 + o2;
    }
};

Comparator&lt;Integer&gt; compMax = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return Math.max(o1, o2);
    }
};

Comparator&lt;Integer&gt; compMin = new Comparator&lt;Integer&gt;() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return Math.min(o1, o2);
    }
};
</code></pre>

<p>&#8220;`</p>

<script language="javaScript">
$(document).ready( function () { $("a[href^='http']:not([href*='" + location.hostname + "'])").attr('target', '_blank'); })
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codility - Aluminium 2014 - Part 1]]></title>
    <link href="http://zh-wang.github.io/blog/2014/06/18/codility-aluminium-2014/"/>
    <updated>2014-06-18T15:54:12+09:00</updated>
    <id>http://zh-wang.github.io/blog/2014/06/18/codility-aluminium-2014</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>This is an analysis of <a href="https://codility.com/programmers/challenges/">Codility - Aluminium 2014 Challenge</a>, Part 1.</p>

<ul>
<li>The problem is, finding the maximum sum of a compact subsequence of array elements after performing a single swap operation. It&rsquo;s a little tricky <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem">maximal subarray</a> problem.</li>
<li>For example, given an array {3, -10, 4, 5}, we can swap 3 and -10 to get a compact subsequence {3, 4, 5}, which has the maximum sum 12</li>
<li>Time bound and space bound are both O(n)</li>
<li>There exists many algorithms to solve maximal subarray problems, but they cannot directly applied to this problem.</li>
</ul>


<!-- more -->


<h2>Analysis</h2>

<ul>
<li>First, we will take a look at the solution of a CLASSIC maximal subarray problem, which means <strong>swap is not allowed</strong>.</li>
</ul>


<p>For a given array <script type="math/tex"> a_0, a_1, \cdots, a_n-1 </script>,</p>

<p>The maximum sum of a compact subsequence can be expressed by the following formula.</p>

<p><script type="math/tex; mode=display">
    \max { \sum_{k=i}^j a_k, 0 \leq i &lt; j \leq n - 1 }
</script></p>

<p>Because we want the maximal part from <script type="math/tex"> i </script> to <script type="math/tex"> j </script>, by thinking reversely, we can calculate the minimal <a href="http://mathworld.wolfram.com/PartialSum.html">partial sum</a> of sub array <script type="math/tex"> a_0, a_1, \cdots, a_x-1 </script> as <script type="math/tex"> f(x) </script>, minimal partial sum of sub array <script type="math/tex"> a_x+1, a_x+2, \cdots, a_n-1 </script> as <script type="math/tex"> g(x) </script>. Then use the whole sum to subtract them if them are minus values.</p>

<p>let <script type="math/tex"> S </script> to be the accumulation of the given array.</p>

<p>let
<script type="math/tex; mode=display">
    f(x) = \min { \min { partial_sum(p), 0 \leq p \leq x - 1 } , 0 }
</script></p>

<p>to be the minimal partial sum of sub array <script type="math/tex"> a_0, a_1, \cdots, a_x-1 </script>.</p>

<p>let
<script type="math/tex; mode=display">
    g(x) = \min { \min { partial_sum(q), x + 1 \leq q \leq n - 1 } , 0 }
</script></p>

<p>to be the minimal partial sum of sub array <script type="math/tex"> a_x+1, a_x+2, \cdots, a_n-w </script>.</p>

<p>Then we calculate the following formula.</p>

<p><script type="math/tex; mode=display">
    \max { S - f(x) - g(x), 0 \leq x \leq n - 1 }
</script></p>

<ul>
<li>OK, then write above thought into Java, we get the following codes</li>
</ul>


<pre><code class="java">
    public int solution(int[] inputs) {
        List&lt;Integer&gt;data = new ArrayList&lt;Integer&gt;();
        for (int i = 0; i &lt; inputs.length; i++) data.add(inputs[i]);
        return cal(data);
    }

    private int cal(List&lt;Integer&gt; A) {
        int n = A.size();
        int S = 0;
        for (Integer integer : A) S += integer;
        List&lt;Integer&gt; B = partial_sum(A, compAdd);
        List&lt;Integer&gt; F = partial_sum(B, compMin);

        Collections.reverse(A);
        List&lt;Integer&gt; D = partial_sum(A, compAdd);
        List&lt;Integer&gt; G = partial_sum(D, compMin);
        Collections.reverse(A);
        Collections.reverse(G);

        int res = 0;
        for (int i = 0; i &lt; n; i++) {
            int f = i - 1 &lt; 0 ? 0 : F.get(i - 1); 
            int g = (i + 1 &gt;= n ? 0 : G.get(i + 1));
            res = Math.max(res, S - (f &lt; 0 ? f : 0) - (g &lt; 0 ? g :0));
        }
        return res;
    }

    private List&lt;Integer&gt; partial_sum(List&lt;Integer&gt; data, Comparator&lt;Integer&gt; comparator) {
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        if (data.size() == 0) {
            return res;
        }
        res.add(data.get(0));
        for (int i = 1; i &lt; data.size(); i++) {
            Integer lastValue = res.get(i - 1);
            Integer currentValue = data.get(i);
            res.add(comparator.compare(lastValue, currentValue));
        }
        return res;
    }

    Comparator&lt;Integer&gt; compAdd = new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o1 + o2;
        }
    };

    Comparator&lt;Integer&gt; compMax = new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Math.max(o1, o2);
        }
    };

    Comparator&lt;Integer&gt; compMin = new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Math.min(o1, o2);
        }
    };
</code></pre>

<script language="javaScript">
$(document).ready( function () { $("a[href^='http']:not([href*='" + location.hostname + "'])").attr('target', '_blank'); })
</script>

]]></content>
  </entry>
  
</feed>
